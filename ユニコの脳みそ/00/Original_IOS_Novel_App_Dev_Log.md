---
tags: [00_DeepThinking, Log, iOS, NovelApp, Kotosekai, DeepDiscussion]
date: 2026-01-19
link: [[00_知識マップ|⬅️ 知識マップへ戻る]]
---
# Original_IOS_Novel_App_Dev_Log

iosアプリで　ことせかい　と言う　小説家になろう　や　カクヨム　などから　小説をダウンロードし　朗読するアプリがある。

iOSアプリは更新がストップし、Androidでは良いアプリ自体がない。

代わりになるようなアプリの作成に向けて　必要な機能や注意点を　複数の専門家たちで議論して
深層ディスカッションAI の発言：

思考時間: 8s
まず結論から言うと、
「ことせかいの代替」を作るなら、

①読みたい小説への“たどり着き方”
②読み上げ体験の気持ちよさ
③権利・規約の安全性

この3つを設計の中心に据える必要があります。
ここを軸に、専門家チームで議論していきます。

👥 本日のメンバー紹介
司会：モデレーターM
テーマ整理と論点の交通整理担当。

佐藤（プロダクトマネージャー）🧠正統派

専門：プロダクト戦略 / MVP設計 / ロードマップ

田中（モバイルエンジニア）🎯実務視点

専門：iOS/Androidネイティブ開発 / オフライン処理 / パフォーマンス最適化

鈴木（UX・UIデザイナー）🎨創造型

専門：読書体験設計 / 情報設計 / アクセシビリティUI

中村（音声・アクセシビリティ専門家）🔍深掘り型

専門：TTS（Text to Speech）/ 視覚障害者向けUX / 音声インターフェース

山本（法務・著作権）🧠正統派

専門：著作権 / 利用規約 / プラットフォームポリシー（App Store / Google Play）

高橋（ビジネス・収益化）💥逆張り

専門：サブスク設計 / ニッチ向けアプリのマネタイズ / コミュニティ運営

ペルソナ代表：読書家Fさん（ヘビーユーザー）🌀パラドックス型

「ことせかい大好きだった一般ユーザー」という想定で、本音を代弁

1. まず「コア体験」と必要機能を定義する
1-1. プロダクト全体像（佐藤：🧠正統派）
「『小説家になろう』『カクヨム』などの小説を、手間なく、耳で楽しめる』
これがコア価値です。」

そのために、MVPとして最低限必要な機能を整理すると：

対応サイトの小説取得

URL貼り付け or ID指定で小説取得

章一覧の取得・管理

途中から再開（しおり機能）

読み上げ（朗読）機能

再生 / 一時停止 / スキップ（章単位・数分単位）

読み上げ速度・ピッチ・声質の変更

バックグラウンド再生（画面OFFでも）

ライブラリ管理

自分の「本棚」機能：お気に入り登録・並び替え

読了・未読・途中のステータス管理

端末ローカルへのキャッシュ（オフライン再生）

プラットフォーム共通の基本

iOS・Android両方で使える設計（Flutter/React Native も選択肢）

最低限のクラッシュ耐性・安定性

2. 技術的な注意点（田中：🎯実務視点）
2-1. 小説取得まわり
スクレイピング前提は危険

HTML構造が変わるたびに壊れる

利用規約違反リスク（後で法務から詳しく）

できれば：

公開されている公式API・RSS・ダウンロード機能があれば、それを優先利用

将来、サイト側と連携・許諾を取れる設計にする（コードを柔軟に）

技術的な実装ポイント：

「章が多い小説」を想定
→ 一気に全部取得ではなく、ページング取得＋バックグラウンドで順次ダウンロード

パース時の注意：

ルビ（ふりがな）タグ、傍点、ルール（※）などをどう扱うか

改行・会話文の扱い（読み上げ時に不自然になりやすい）

2-2. 読み上げエンジンまわり
iOS

AVSpeechSynthesizer（標準TTS）利用が基本

Android

TextToSpeech API + 各種日本語エンジン

注意点：

OS標準TTSは「端末の設定」に依存する
→ アプリ側で推奨設定ガイドを用意すると親切

将来、**クラウドTTS（より自然な声）**を使う可能性も見据え、
抽象化レイヤーを作っておく（TextSource -> SpeechEngine のインターフェース設計）

3. UX観点からの必須機能（鈴木：🎨創造型）
3-1. ユーザーの「一連の流れ」で考える
読みたい小説を見つける

アプリに登録する

読み上げ条件（声・速度）を調整する

通勤・家事中・就寝前などで聴く

続きから再開する

この流れをスムーズにするために：

URL共有インテント

ブラウザで小説ページを開いて「共有」→ アプリに送るだけで登録完了

ワンタップで続きから再生

起動したら「前回の続き」をドーンと表示

物理ボタン連携（できる範囲で）

イヤホンの再生/停止ボタンで操作できるように

3-2. 読書系ならではのUX
しおり・章ジャンプ

「前の会話シーンに戻りたい」「さっきの重要な場面だけ聞き直したい」ニーズ

夜間モード

視覚ユーザーも使うので、読書アプリらしいダークモード

書式問題

なろう系の「——」「……」「（笑）」など、
TTSで読むと変になる部分の調整（後で音声専門家と連携）

4. 音声・アクセシビリティ視点（中村：🔍深掘り型）
4-1. 読み上げ品質を上げるための機能
読み上げプリプロセス

ルビ部分を削除 or 読み替え

記号の正規化（「……」→「…」など）

顔文字やネットスラングの扱い（必要なら飛ばすオプション）

単語辞書機能（あると神）

固有名詞や当て字が多い作品に対して、
ユーザーが「この単語はこう読む」と登録できる機能

長時間再生への配慮

再生時間タイマー（睡眠タイマー）

章末で一時停止するオプション

4-2. アクセシビリティ対応
そもそも「視覚障害者・弱視の方」が多く使う可能性

必須：

VoiceOver / TalkBack対応（ボタンラベルの適切な設定）

大きめフォント・高コントラストテーマ

「ことせかいの精神的後継」を目指すなら、
アクセシビリティは最初から設計の中心に置いたほうが良い。

5. 法務・著作権・規約の注意点（山本：🧠正統派）
ここが最重要の落とし穴です。

5-1. 著作権の基本整理
小説自体には著作権がある

ただし、

「ユーザーが自分の端末で読む／聞く」こと自体は、
多くの国で私的複製の範囲内と解釈されることが多い

しかし問題は

アプリがサイトのコンテンツをどう取得するか

アプリが第三者に配布していないか

5-2. サイトごとの利用規約
「小説家になろう」「カクヨム」など、それぞれ利用規約で

自動取得・スクレイピング

商用利用アプリ
をどこまで許容しているかが違う。

注意点：

規約違反になることは絶対に避ける

サイト運営に迷惑をかけると、アプリ自体が止められる可能性

できれば：

公式に問い合わせて「こういう用途のアプリを作りたいが問題ないか」を確認

将来、API提供の交渉余地も生まれる

5-3. ストア審査の観点
App Store / Google Play は

著作権侵害の可能性があるコンテンツアプリには厳しい

ガイドライン上、

「ユーザーが自分で取得したコンテンツを再生するツール」

という位置づけを明確にする必要がある

例：

サーバー側で小説を保存・配布しない

アプリはあくまで「ユーザーのブラウザで見られる公開ページを、一時的に読み上げ用に整形するだけ」という設計

6. ビジネス・継続運営の視点（高橋：💥逆張り）
「無料でいいアプリを作っても、開発が止まったらことせかいと同じ運命になります。」

6-1. ランニングコストの想定
サーバーをほぼ使わない設計にすれば、コストは低くできる

ただし、クラッシュレポート・簡易バックエンドぐらいは必要かも

クラウドTTSを使うなら、
→ 再生時間に応じて課金しないと赤字

6-2. マネタイズ案（ユーザーに優しい順）
寄付（投げ銭）＋広告なし

買い切り（Pro版）

無料版：同時登録作品数に制限 / 一部機能制限

有料版：制限解除＋高級機能

サブスクリプション（慎重に）

毎月のクラウドTTSコストが発生する場合のみ検討

ポイント：

コアターゲットは「かなり熱心な小説読者」なので、
少数の熱心ユーザーに支えてもらうモデルが現実的

「作者さん側にもメリットがある仕組み」（例：お気に入り作者へのリンク、感想やブクマ誘導）を入れると、協力を得やすい

7. ユーザー視点からの「欲しい機能」優先度（読書家F：🌀パラドックス型）
「正直、最初は**『ちゃんと読み上げてくれて落ちない』**だけで十分…」

優先度（高→低）：

安定して最後まで読み上げられる

続きからワンタップで再生できる

速度・声の調整が簡単

オフライン再生（圏外や飛行機でも聴きたい）

URL共有からすぐ登録できる

しおり or クリップ（好きなシーンをマーク）

辞書・読み上げカスタマイズ（マニア向け）

「細かいカスタマイズは、後から徐々に増えていけばOK。
最初から万能アプリを目指すより、**『壊れない・聞きやすい』のが一番うれしい。」

8. 専門家同士の補強・反論
田中（🎯）→ 山本（🧠）へ

「規約順守のためにも、サーバー側に本文を保存しない設計にしたい。
毎回ユーザー端末から直接取得して、ローカルにキャッシュする形ならどうか？」

→ 山本「その方向が安全。加えて『利用は各サイトの規約の範囲で』という注意書きも必要。」

鈴木（🎨）→ 中村（🔍）へ

「プリプロセスが増えるほど、UXが複雑にならないか？」

→ 中村「基本は自動処理にして、辞書など“オタク機能”だけ設定画面の奥に置けば、一般ユーザーは迷わない。」

高橋（💥）→ 全員

「アクセシビリティを強く打ち出すなら、
“視覚障害者支援アプリ”として補助金や助成金の可能性もある。
ビジネスとしても、その線を調べる価値がある。」

9. 「ことせかい代替アプリ」のMVP機能まとめ
9-1. 最初のバージョンで入れたい機能 TOP10
対応サイトの小説URLを貼るだけで登録

章一覧取得＆選択

バックグラウンド再生・ロック画面からの操作

再生速度・ピッチ調整

前回の続きから再生（自動しおり）

ローカルキャッシュによるオフライン再生

URL共有（ブラウザ→アプリ）の連携

シンプルな本棚（タイトル・作者・進捗）

夜間向けダークテーマ

基本的なアクセシビリティ対応（スクリーンリーダー・大きい文字）

9-2. 絶対に外せない注意点 5つ
各サイトの利用規約を必ず確認し、違反しない実装にする

サーバー側で小説本文を保存・再配布しない設計にする

HTML構造変更に強いパーサー設計（壊れたときに即修正できるように）

アクセシビリティを“おまけ”にせず、最初から設計に組み込む

開発・保守が続けられる規模とマネタイズを、最初から現実的に考える

議論の質・自己評価
視点の多様性：プロダクト・技術・UX・音声・法務・ビジネス・ユーザーの7視点

深掘り：機能だけでなく、「規約」「継続性」まで踏み込めた

まだ足りない点：

具体的な技術スタック（ネイティブ / Flutter / React Native）の比較

実装ロードマップ（1〜3ヶ月で何を作るか）

競合アプリ分析

自己評価：85点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る（例：iOSだけに絞る / Android特化で考える など）

さらに意外な視点から議論する（例：作者・サイト運営側の視点）

さらに議論を続ける（今のメンバーで詳細化）

実行可能な次のアクションを提案（「まず何から手を付けるか」具体化）

結論をまとめる

最初に戻る

番号またはざっくり方向性だけ教えてもらえれば、次のラウンドに進行する。

あなた:
7
深層ディスカッションAI の発言：

思考時間: 5s
まず、**「今から何をすれば、ことせかい代替アプリに一歩近づくか」**を、
時間軸とタスクに落として整理していきます。

👥 本日のメンバー（継続）
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UX・UIデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

山本（法務・著作権）🧠正統派

高橋（ビジネス・収益化）💥逆張り

読書家F（ヘビーユーザーペルソナ）🌀パラドックス型

1. まず決めること（0〜1日でできるアクション）
1-1. プロダクトの「方針を紙に書く」（佐藤🧠）
「コードを書く前に、A4一枚でいいので方向性を文字にしてほしい。」

今すぐできるアウトプット（メモでOK）：

ターゲットユーザー

例）「なろう・カクヨムを毎日読む／聞く人」「ことせかい難民」

対応プラットフォームの優先順位

例）

優先：Android（今いいアプリがない）

次点：iOS（ことせかい難民向け）

MVPでやること・やらないこと

やる：

URLから小説取得

読み上げ

続きから再生

やらない：

高度な辞書機能

多言語対応

凝ったSNS機能

成功のイメージ（簡単でいい）

例）「自分が毎日1時間は、このアプリで小説を聞いている状態」

➡️ アクション：
今日中に、上の4項目をテキストで書き出す。

2. 技術的な最初の一手（田中🎯）
「“小説1話を端末上でTTS読み上げできる”ところまで一気に行くと、モチベが上がります。」

2-1. 技術スタックの仮決定
アクション：

① 「まずどちらから作るか」を決める

ことせかいがiOS → Androidから攻めるのもアリ

② ネイティブ / クロスプラットフォームの仮決定

Androidネイティブ（Kotlin）

or Flutter で iOS/Android両対応を視野に
（ここは、今のご自身のスキルに合わせて選ぶのがベター）

2-2. 「Hello 読み上げ」プロトタイプ
最初の技術ミニゴール：

画面にテキスト入力欄＋「読み上げ」ボタン

押したらOSのTTSで日本語読み上げ

再生・停止だけでもOK

具体アクション：

開発環境セットアップ（Android Studio / Xcode / Flutter環境など）

Gitリポジトリ作成（GitHub等）

「TTSサンプルコード」で検索して、まずサンプル通り動かす

ここまでは**「小説サイト関係なし」**でOK。
読み上げ体験の土台を先につくる。

3. ユーザー体験のたたき台づくり（鈴木🎨）
「紙とペンでもいいので、画面を3〜4枚ラフで描いてみてほしい。」

3-1. 必要な画面（MVP版）
ホーム / 本棚画面

登録済みの小説一覧

「前回の続き」ボタンを目立つ位置に

作品追加画面

URL入力欄

「貼り付け→取得」ボタン

章一覧画面

章リスト

再生ボタン or 再生画面へ遷移

再生画面

再生 / 一時停止

進捗バー

速度変更（0.8〜1.5倍ぐらい）

アクション：

紙 or メモアプリで、上の4画面を
「どう並んでいて、どう遷移するか」を矢印付きで描く

その際、「アプリ起動→2タップ以内で続き再生」を目標に設計してみる

4. 小説取得まわりの最初のステップ（田中🎯＋中村🔍）
「いきなり本格スクレイピングではなく、まずは“ペーストしたHTMLから本文を抜く”ミニ実験から。」

4-1. ローカルでのテキスト抽出実験
アクション：

ブラウザで、よく読む小説の1話ページを開く

HTMLを保存する or 全文コピーしてローカルファイルに貼る

開発環境で、そのHTMLから本文部分だけを抜き出すスクリプトを書いてみる

最初は正規表現＋目視でOK

慣れてきたら、HTMLパーサー（jsoup / BeautifulSoup相当など）を使う

抜き出した本文を、さっきの「TTSプロトタイプ」に流し込んで読み上げさせる

ここまで行くと、「おお、もう半分できたじゃん」という感覚になりやすい。

5. 法務・規約的に最低限やっておきたいこと（山本🧠）
「今すぐ弁護士を雇え、という話ではなく、“自分なりのメモ”だけでも作っておくと後で助かります。」

5-1. 利用規約のざっくりチェック
アクション：

よく使うサイト（例：小説家になろう / カクヨム）の利用規約ページを読む

気になった箇所をメモに箇条書き

「自動取得」「スクレイピング」「アプリ」で検索しながら読む

メモの最後に、

「これはグレーかも」「ここは絶対守るべき」と自分なりの色分け

5-2. 将来のための準備メモ
「将来、正式に確認したいことリスト」を作っておく
例）

ユーザーの端末内での読み上げツールとして使うことは問題ないか

貴サイトのサーバーに過度な負荷をかけない設計をするが、それでもNGなことはあるか

これは今すぐ問い合わせなくてもよいですが、
「いつか聞くこと」を整理しておくと、スムーズに動ける。

6. ビジネス・継続運営のミニプラン（高橋💥）
「最初から完璧なビジネスモデルは要りません。
大事なのは“継続する理由”と“時間の使い方の上限”を決めておくこと。」

6-1. 自分ルールを決める
アクション：

このプロジェクトに使う時間の目安を決める

例）「平日1時間＋休日2時間まで」

最低半年続けたときに、どうなっていたいかを書く

例）「自分＋数人の友達が、毎日このアプリで小説を聞いている」

マネタイズの仮方針（現時点の暫定案でOK）

例）

初期：完全無料・広告なし

ユーザーが100人超えたら、寄付ボタン検討

クラウドTTSを入れるなら、そのタイミングで有料版検討

こうしておくと、
「お金にならないからやめよ…」ではなく
「自分の目標はここだった」と思い出せる。

7. 読書家視点からの「今すぐやってくれたら嬉しいこと」（読書家F🌀）
「ぶっちゃけ、完全版はいらないので、
まずは“1作品を最後まで安定して読み上げてくれる”だけで神です。」

Fさんからの要望を、開発タスクに翻訳すると…

アプリ起動 → 前回の作品の続きがすぐ再生できる

読み上げ中に、落ちたり変に止まったりしない（安定性優先）

速度を変えた設定を次回も覚えていてほしい

➡️ アクション：MVPの「完了条件」として、上の3つを仕様書に書き込む。

8. 「次の1〜2週間」でのロードマップ案（全員で整理）
ステップ1：1〜3日目

プロダクトの方針メモ（ターゲット・MVP・成功イメージ）を書く（佐藤案）

技術スタックを決め、開発環境＆Gitリポジトリを用意（田中案）

ざっくり画面ラフ（4画面）を描く（鈴木案）

ステップ2：4〜7日目

TTSお試しアプリ（入力テキストを読み上げるだけ）を作る

本棚画面＆再生画面だけ、UIモックをアプリ側で仮実装

メインで対応したいサイト1つの利用規約を読み、気になったところをメモ（山本案）

ステップ3：8〜14日目

好きな小説1作品のHTMLを保存し、本文抽出スクリプトを作る

抽出した本文をTTSで読み上げるプロトタイプを完成

「アプリ起動→前回の続き再生」までの流れを仮実装

アクセシビリティ簡易チェック（スクリーンリーダーで操作できるか）（中村案）

この2週間で
「1作品を読み上げできるプロトタイプ」
まで行ければ、あとは改良＆拡張のフェーズに入れる。

9. 議論の質評価（今回）
「今すぐ何をやるか」がかなり具体的になった

時間軸（今日〜2週間）も提示できた

まだ不足しているのは、「どの技術を選ぶか」の踏み込み比較

自己評価：88点 / 100点

10. 次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「Androidだけに絞った技術スタック比較をしたい」など

さらに意外な視点から議論する

さらに議論を続ける（今の方向で、もっと細かい実装レベルに落とす）

実行可能な次のアクションを提案（さらに細かく“タスク分解”も可能）

結論をまとめる

最初に戻る

番号か、「Androidの話を深掘り」「UIをもっと詰めたい」など、
ざっくりした方向性を教えてもらえれば、次のラウンドに進行する。

あなた:
6
深層ディスカッションAI の発言：
では、「さらに議論を続ける」ということで、
前回の「やることリスト」を、実装レベルにかなり細かく落とし込む議論に入る。

👥 参加メンバー（継続）
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UX・UIデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

山本（法務・著作権）🧠正統派

高橋（ビジネス・収益化）💥逆張り

読書家F（ヘビーユーザーペルソナ）🌀パラドックス型

1. アプリ全体のアーキテクチャ方針
1-1. どんなレイヤー構造にするか（佐藤🧠＋田中🎯）
田中から：

「最初から“綺麗すぎるアーキテクチャ”は要らないが、
3レイヤーぐらいには分けておくと後が楽。」

基本構造（シンプル版）：

UIレイヤー

画面・View・ViewModel（またはPresenter）

ドメインレイヤー

「作品」「章」「再生状態」といったビジネスロジック

UseCase / Service クラス

データレイヤー

ローカルDB（作品一覧・進捗）

ネットワーク（HTML取得）

TTSエンジンへの橋渡し

1-2. 抽象化しておきたいポイント
小説取得
→ NovelSource インターフェース（なろう / カクヨム / その他サイトで実装を変える）

TTSエンジン
→ SpeechEngine インターフェース（OS標準 / 将来クラウドTTSなどを差し替え）

こうしておくと、「別サイト対応」「別TTS対応」を足すときに、
コアロジックを壊さずに拡張しやすい。

2. 画面フローの詳細設計（鈴木🎨）
2-1. 画面と遷移
鈴木から：

「MVPとして4〜5画面に絞って、遷移をはっきり定義しておくと、実装が迷わない。」

① スプラッシュ → ホーム（本棚）

アプリ起動

設定値・前回再生中の作品を読み込み

ホーム画面へ

② ホーム（本棚画面）

上部：「前回の続き」カード

作品タイトル

章タイトル

再生ボタン 1つ

下部：登録済み作品のリスト

タイトル・作者名・進捗バー

タップ → 作品詳細へ

右下：+ボタン（作品追加）

③ 作品詳細画面

作品情報（タイトル・作者）

「再生中の章」表示

章一覧（リスト）

再生済み・未再生の状態表示

タップ → 再生画面へ

④ 再生画面

上：作品名＋章タイトル

中央：再生バー

現在位置・章の長さ

下：

再生/一時停止ボタン（大きく）

前の章 / 次の章ボタン

速度変更（例：0.8 / 1.0 / 1.2 / 1.5）

右上：メニュー（スリープタイマー・音声設定）

⑤ 作品追加画面

URL入力欄＋貼り付けボタン

「取得」ボタン

取得中はインジケータ

成功時：
→ 作品情報を表示 → 「本棚に追加」ボタン

2-2. 重要なUXルール
アプリ起動から2タップ以内で続き再生

起動 → 「前回の続き」カードの再生ボタン

読み上げ中、余計な操作をさせない

再生画面はシンプルに

設定は別画面に逃がす

3. データモデルと永続化（田中🎯）
3-1. 最小限のデータ構造
田中から：

「最初は、DBテーブルを3つに絞るぐらいでいい。」

1. 作品（Novel）

id：ローカルで振るID

title

author

sourceType：なろう / カクヨム / その他

sourceUrl

createdAt

updatedAt

2. 章（Chapter）

id

novelId

index：第何話か（0,1,2,…）

title

sourceUrl

localPath：ローカルキャッシュのファイルパス（テキスト保存）

length：文字数 or 再生時間（あとで計算してもOK）

3. 再生状態（PlaybackState）

novelId

chapterId

positionMillis：再生位置

speed：1.0f 等

updatedAt

3-2. どこまでローカル保存するか
小説本文はテキストファイルとして端末に保存

章ごとに 1ファイル

万が一のため「削除」機能も用意

DBにはメタ情報だけ（タイトル・URL・進捗など）

こうすることで、
「あとでテキストフォーマットを変えたい」となっても、
ファイルだけ再加工すればよい。

4. 小説取得・解析モジュールの詳細（田中🎯＋中村🔍）
4-1. 役割分割
NovelSource インターフェース（例）

fun fetchNovelMeta(url): NovelMeta
（タイトル・作者・章一覧URL 等）

fun fetchChapterList(novelMeta): List<ChapterMeta>

fun fetchChapterBody(chapterMeta): String
（本文テキスト）

実装例：

NaroNovelSource（小説家になろう）

KakuyomuNovelSource

GenericHtmlSource（その他）

4-2. 本文抽出処理
中村から：

「TTS用に、HTML→テキストにする時点で
ある程度“読みやすいテキスト”にしておくとクオリティが上がる。」

処理のステップ例：

HTMLをパースして本文ブロックのみ抽出

タグを除去（p, br → 改行）

ルビタグ・注釈をどうするか決める

ルビは削除するのが無難（読みが二重になるのを防ぐ）

連続記号の正規化

「……」→「…」

「――」→「―」

顔文字・AAなどが多い行を丸ごと削除（任意）

ここは後からチューニングが効くように、
TextPreprocessor クラスにまとめておくとよい。

5. TTSエンジン・再生制御の詳細（中村🔍）
5-1. SpeechEngine の中身
提供すべき機能：

prepare(text, config)：読み上げ準備

play()

pause()

stop()

seek(positionMillis)

状態イベントコールバック

onStart, onComplete, onError, onProgress

内部ではOS依存の処理を隠蔽：

Androidなら TextToSpeech の speak / playSilentUtterance 等

iOSなら AVSpeechUtterance + AVSpeechSynthesizer

5-2. 章をまたいだ再生
課題：

1章が長すぎると、「途中でアプリが落ちたときの位置復元」が難しい

解決案：

テキストを一定の長さでチャンク分割（例：数千文字ずつ）

各チャンクの開始時に「現在位置」を保存

章の終わりまで行ったら、自動で次の章のテキストを読み込む

これにより、
「長編なのに一気に読み上げさせてOSが重くなる」
という問題も多少緩和できる。

5-3. バックグラウンド再生
OSの制限を守りつつ、
オーディオフォアグラウンドサービス（Android）や
Background Audio（iOS）の設定が必要

ロック画面からの再生/停止ボタンは、
メディアセッションAPIと連携

ここは技術的に少し重めなので、**MVPでは「バックグラウンド再生だけまず対応」「ロック画面操作は次フェーズ」**として分けるのもアリ。

6. 安定性・エラー処理・ログ（田中🎯＋高橋💥）
6-1. ユーザーに見せるエラーと、内部のログを分ける
ユーザー表示：

「ネットワークに接続できませんでした」

「本文の取得に失敗しました。もう一度お試しください」

内部ログ：

どのURLで失敗したか

HTML構造変更の可能性など

アクション例：

最初から、最低限のログ保存仕組みを入れる（ローカルにテキストでも）

クラッシュレポートツール（Firebase Crashlytics など）を導入（可能なら）

高橋から：

「不具合を直すスピードが、ユーザーの信頼に直結する。
最初から“何が起きたか分かる状態”を作っておくことが、
結果として保守コスト削減につながる。」

7. アクセシビリティ実装の具体（中村🔍）
7-1. 画面構造とラベル
ボタン・アイコンには必ず代替ラベルを付ける

例：「▶︎」アイコン → アクセシビリティラベル：「再生」

リスト項目には

タイトル→まず読み上げ

進捗情報→「第5話まで再生済み」など簡潔に

7-2. 操作フローをシンプルに
VoiceOver / TalkBackユーザーは、画面に情報が多いほど操作が大変

再生画面は「再生/停止」「前へ」「次へ」「速度」程度に絞る

テスト方法：

実機でスクリーンリーダーをオン

目をつぶって、「前回の続き再生」まで操作してみる

ひっかかったところをメモ → UI調整

これは数時間あればできるので、
初期の段階から何度か繰り返すとクオリティが上がる。

8. 実際のタスク分解（チケット例）
佐藤から：

「ここまでの話を、実際にタスクとして並べるとイメージしやすい。」

8-1. 初期スプリント（例：2週間）のチケット案
カテゴリ：基盤

 プロジェクト作成（Android / iOS / Flutter いずれか）

 Gitリポジトリ作成・READMEにプロジェクト方針を書く

 TTSサンプル（固定テキストを読み上げ）

カテゴリ：データモデル・永続化

 Novel / Chapter / PlaybackState のエンティティ定義

 ローカルDB（Room / CoreData / etc.）のセットアップ

 本文テキスト保存用ディレクトリの決定・読み書きテスト

カテゴリ：UI（MVP）

 ホーム画面：ダミーデータで本棚リスト表示

 再生画面：再生ボタン押下でダミーテキストを読み上げ

 「前回の続き」カードのデザインだけ作る

カテゴリ：小説取得プロトタイプ

 任意の小説ページHTMLをローカルに保存して、本文抽出処理を実験

 TextPreprocessor クラス作成（最低限：タグ除去＋改行整形）

 抽出したテキストをTTSで読み上げる一連の流れを作る

カテゴリ：再生状態管理

 再生位置（positionMillis）を定期的にDBへ保存

 アプリ再起動時に、最後に再生していた章・位置を復元

 ホーム画面の「前回の続き」カードに反映

カテゴリ：簡易アクセシビリティ

 主要ボタンのアクセシビリティラベル設定

 スクリーンリーダーで操作してみて、詰まる箇所をメモ

9. ユーザー視点からのチェック（読書家F🌀）
Fから：

「正直、細かいことは分からないので、
“最初の版で、これが出来てたら十分うれしい”というチェックポイントをまとめてほしい。」

初版の品質チェックリスト（ユーザー目線）：

アプリ起動 → 「前回の続き再生」まで迷わず行ける

30分〜1時間ぐらい聞いても、アプリが落ちない / 変に止まらない

通信オフにしても、キャッシュ済みの章は再生できる

速度設定を変えたら、次回起動時もそのまま

HTML由来の変な読み（ルビの二重読みなど）が致命的に多くない

この5つが守られていれば、
「ことせかいの代替として、十分日常で使いたいレベル」
になる可能性が高い。

10. 専門家間の補足・微調整
田中🎯 → 佐藤🧠
「タスクが多くなってきたので、必須と後回しOKタグを付けて管理したい」
→ 佐藤「同意。まずは“1作品連続再生”に直結しないタスクは後ろに回してもいい。」

鈴木🎨 → 中村🔍
「アクセシビリティを入れつつ、見た目がゴチャゴチャしないようにしたい」
→ 中村「ラベルは裏側の話なので、見た目はシンプルのままで大丈夫。」

高橋💥 → 全員
「初期ユーザーからのフィードバックをもらう仕組み（簡単なフォームやメールリンク）を最初から入れておくべき。」

議論の質評価（今回）
実装レベル（クラス・データ構造・画面フロー）まで踏み込めた

「タスク」として実行しやすい粒度になっている

まだ不足しているのは、

具体的な技術選定（例：AndroidならKotlin＋Jetpack Composeまで決めるか）

実際のコード例やサンプル設計（クラス図レベル）

自己評価：90点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「Androidの技術スタックだけを徹底的に議論」

例）「HTML解析・テキスト整形だけにフォーカス」

さらに意外な視点から議論する

例）「作者・サイト運営者にメリットを出す機能を考える」

さらに議論を続ける

例）今度は簡単なクラス図・疑似コードレベルまで踏み込み

実行可能な次のアクションを提案

今日〜1週間の“具体タスクリスト”をもっと細かく切り分け

結論をまとめる

最初に戻る

番号でも、「Androidコード寄りで」「UIデザイン寄りで」など一言でもOK。
次のラウンドに議論をつなげる。

あなた:
6
深層ディスカッションAI の発言：

思考時間: 6s
では、「さらに議論を続ける」ということで、
今回は かなりコード寄り（クラス構成・疑似コード） まで踏み込んでいく。

👥 参加メンバー（継続）
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア / Android想定）🎯実務視点

鈴木（UX・UIデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

山本（法務・著作権）🧠正統派

高橋（ビジネス・収益化）💥逆張り

読書家F（ヘビーユーザーペルソナ）🌀パラドックス型

ここからは、Android（Kotlin + Jetpack Compose）でMVPを作る前提で話を進める。
※他技術でも概念はほぼ共通。

1. 全体のクラス構成イメージ（田中🎯）
田中：

「ごちゃごちゃするので、まず“登場人物”を整理する。」

1-1. レイヤー別ざっくり構成
UIレイヤー

HomeViewModel

NovelDetailViewModel

PlayerViewModel

それに対応する Composable 画面

ドメイン / アプリケーションレイヤー

NovelRepository

PlaybackManager

NovelSourceRegistry

TextPreprocessor

データレイヤー

LocalNovelDataSource（Room など）

LocalChapterStorage（テキストファイル保存）

RemoteHtmlClient（HTTP取得）

NaroNovelSource / KakuyomuNovelSource（HTML解析）

音声再生 / OS連携

SpeechEngine（インターフェース）

AndroidSpeechEngine（実装）

PlaybackService（フォアグラウンドサービス）

2. データモデルとリポジトリ（田中🎯）
2-1. エンティティ（Kotlinデータクラス例）
data class Novel(
    val id: Long,
    val title: String,
    val author: String?,
    val sourceType: SourceType,
    val sourceUrl: String,
    val createdAt: Long,
    val updatedAt: Long
)

enum class SourceType {
    NARO, KAKUYOMU, OTHER
}

data class Chapter(
    val id: Long,
    val novelId: Long,
    val index: Int,
    val title: String,
    val sourceUrl: String,
    val localPath: String?, // nullなら未キャッシュ
    val lengthChars: Int?
)

data class PlaybackState(
    val novelId: Long,
    val chapterId: Long,
    val positionMillis: Long,
    val speed: Float
)
2-2. リポジトリの役割
interface NovelRepository {
    suspend fun getAllNovels(): List<Novel>
    suspend fun getNovel(novelId: Long): Novel?
    suspend fun getChapters(novelId: Long): List<Chapter>
    suspend fun getPlaybackState(novelId: Long): PlaybackState?

    suspend fun addNovelFromUrl(url: String): Long // 追加してID返す
    suspend fun cacheChapter(chapterId: Long): Chapter
    suspend fun updatePlaybackState(state: PlaybackState)
}
内部では：

DB操作（Room）

NovelSource を呼んで、章一覧や本文取得

本文をファイル保存 (LocalChapterStorage)

をまとめて扱う。

3. 小説取得周りのインターフェース設計（田中🎯＋中村🔍）
3-1. NovelSource と Registry
interface NovelSource {
    suspend fun fetchNovelMeta(url: String): NovelMeta
    suspend fun fetchChapters(meta: NovelMeta): List<ChapterMeta>
    suspend fun fetchChapterBody(chapterMeta: ChapterMeta): String
}

data class NovelMeta(
    val title: String,
    val author: String?,
    val sourceType: SourceType,
    val baseUrl: String
)

data class ChapterMeta(
    val index: Int,
    val title: String,
    val url: String
)

class NovelSourceRegistry(
    private val naroSource: NovelSource,
    private val kakuyomuSource: NovelSource,
    private val genericSource: NovelSource
) {
    fun findSource(url: String): NovelSource {
        return when {
            "syosetu.com" in url -> naroSource
            "kakuyomu.jp" in url -> kakuyomuSource
            else -> genericSource
        }
    }
}
3-2. 本文抽出の流れ（疑似コード）
suspend fun NovelRepository.addNovelFromUrl(url: String): Long {
    val source = sourceRegistry.findSource(url)
    val meta = source.fetchNovelMeta(url)
    val novelId = db.insertNovel(meta.toEntity())

    val chaptersMeta = source.fetchChapters(meta)
    val chapterEntities = chaptersMeta.map { it.toEntity(novelId) }
    db.insertChapters(chapterEntities)

    return novelId
}
NaroNovelSource の中では：

RemoteHtmlClient で HTMLを取得

HTMLパーサーでタイトル・作者・章リストを抽出

本文部分のCSSセレクタを決めて抜く

ここは後からチューニングしやすいように、1サイト1クラスに閉じ込める。

4. 本文整形（TextPreprocessor）の具体設計（中村🔍）
中村：

「TTSに渡す前に、テキストを“読みやすい形”に変換するクラスを1つ用意する。」

4-1. Preprocessor インターフェース
interface TextPreprocessor {
    fun preprocess(raw: String): String
}
4-2. 具体的な処理ステップ例（疑似コード）
class JapaneseNovelTextPreprocessor : TextPreprocessor {

    override fun preprocess(raw: String): String {
        var text = raw

        // 1. ルビの除去（<ruby>漢字<rt>かんじ</rt></ruby> → 漢字）
        text = removeRubyTags(text)

        // 2. HTMLエンティティ解除（&nbsp; &lt; など）
        text = decodeHtmlEntities(text)

        // 3. 連続記号の正規化
        text = text
            .replace("……", "…")
            .replace("――", "ー")

        // 4. 顔文字・AAっぽい行の削除（記号が多い行）
        text = removeEmojiLikeLines(text)

        // 5. 不要な空行の圧縮
        text = compressEmptyLines(text)

        return text
    }

    private fun removeRubyTags(text: String): String {
        // 正規表現やHTMLパーサーで <ruby>...</ruby> を本体だけ残す
        // 疑似実装
        return text
    }

    private fun removeEmojiLikeLines(text: String): String {
        return text.lines()
            .filterNot { line -> isTooSymbolic(line) }
            .joinToString("\n")
    }

    private fun isTooSymbolic(line: String): Boolean {
        val symbolCount = line.count { it in "!?()（）ｗw…―-_=+*/\\" }
        return line.length > 0 && symbolCount.toDouble() / line.length > 0.5
    }

    private fun compressEmptyLines(text: String): String {
        return text
            .replace(Regex("\n{3,}"), "\n\n")
    }
}
ここまでやっておくと、「ルビ二重読み」「謎の記号だらけ読み上げ」がかなり減る。

5. TTS・再生制御の詳細（中村🔍）
5-1. SpeechEngine と実装
interface SpeechEngine {
    fun setConfig(config: SpeechConfig)
    fun setListener(listener: SpeechListener)

    fun speak(text: String, startPositionMillis: Long = 0L)
    fun pause()
    fun resume()
    fun stop()

    fun getCurrentPositionMillis(): Long
}

data class SpeechConfig(
    val speed: Float,
    val pitch: Float,
    val language: String = "ja-JP"
)

interface SpeechListener {
    fun onStart()
    fun onComplete()
    fun onError(error: Throwable)
    fun onProgress(positionMillis: Long)
}
AndroidSpeechEngine では内部で TextToSpeech を保持し、
onUtteranceCompleted 的なコールバックから onProgress を呼ぶイメージ。

5-2. 章を跨いだ再生（PlaybackManager）
class PlaybackManager(
    private val repo: NovelRepository,
    private val speech: SpeechEngine,
    private val preprocessor: TextPreprocessor
) {

    suspend fun playNovelFromLastPosition(novelId: Long) {
        val state = repo.getPlaybackState(novelId)
        val chapters = repo.getChapters(novelId)

        val startChapter = chapters.firstOrNull { it.id == state?.chapterId }
            ?: chapters.firstOrNull() ?: return

        playChapter(novelId, startChapter, state?.positionMillis ?: 0L)
    }

    suspend fun playChapter(novelId: Long, chapter: Chapter, positionMillis: Long = 0L) {
        val text = loadChapterText(chapter)
        val processed = preprocessor.preprocess(text)

        speech.setListener(object : SpeechListener {
            override fun onStart() { /* 状態更新 */ }

            override fun onComplete() {
                // 次の章があれば自動再生
                // ここで repo.updatePlaybackState を「次の章の先頭」で保存
            }

            override fun onError(error: Throwable) {
                // ログ＆UIに通知
            }

            override fun onProgress(position: Long) {
                // 数秒おきに再生位置を保存
                val state = PlaybackState(
                    novelId = novelId,
                    chapterId = chapter.id,
                    positionMillis = position,
                    speed = currentSpeed()
                )
                // コルーチンで非同期保存
            }
        })

        speech.speak(processed, positionMillis)
    }

    private suspend fun loadChapterText(chapter: Chapter): String {
        if (chapter.localPath != null) {
            return localChapterStorage.read(chapter.localPath)
        }
        val text = downloadChapterText(chapter)
        val path = localChapterStorage.save(chapter, text)
        repo.updateChapterLocalPath(chapter.id, path)
        return text
    }
}
実際にはチャンク分割なども入るが、MVPでは「1章 = 1テキスト」で始めてもよい。

6. ViewModel と UI のつなぎ（鈴木🎨＋田中🎯）
6-1. HomeViewModel のイメージ
data class HomeUiState(
    val recentNovel: Novel?,
    val recentChapterTitle: String?,
    val novels: List<NovelListItem>,
    val isLoading: Boolean = false
)

data class NovelListItem(
    val id: Long,
    val title: String,
    val author: String?,
    val progressText: String // 例「5/120話」
)

class HomeViewModel(
    private val repo: NovelRepository,
    private val playbackManager: PlaybackManager
) : ViewModel() {

    private val _uiState = MutableStateFlow(HomeUiState(null, null, emptyList()))
    val uiState: StateFlow<HomeUiState> = _uiState

    init {
        viewModelScope.launch { loadHome() }
    }

    private suspend fun loadHome() {
        _uiState.update { it.copy(isLoading = true) }
        val novels = repo.getAllNovels()
        // 進捗計算などしてNovelListItemに変換
        _uiState.update {
            it.copy(
                novels = novels.map { n -> toListItem(n) },
                recentNovel = findRecentNovel(),
                recentChapterTitle = findRecentChapterTitle(),
                isLoading = false
            )
        }
    }

    fun onClickResume() {
        val novelId = _uiState.value.recentNovel?.id ?: return
        viewModelScope.launch {
            playbackManager.playNovelFromLastPosition(novelId)
        }
    }
}
6-2. Compose側のざっくり構造
@Composable
fun HomeScreen(
    viewModel: HomeViewModel,
    onNovelClick: (Long) -> Unit
) {
    val state by viewModel.uiState.collectAsState()

    Column {
        state.recentNovel?.let { novel ->
            ResumeCard(
                title = novel.title,
                chapterTitle = state.recentChapterTitle ?: "",
                onClick = { viewModel.onClickResume() }
            )
        }

        NovelList(
            items = state.novels,
            onItemClick = onNovelClick
        )
    }
}
「起動 → 前回の続き再生」がシンプルに見える構造になっている。

7. アクセシビリティをコードでどう仕込むか（中村🔍）
7-1. Composeでの例
@Composable
fun ResumeCard(
    title: String,
    chapterTitle: String,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .semantics {
                contentDescription = "前回の続き、$title、$chapterTitle から再生"
            }
    ) {
        Column(Modifier.padding(16.dp)) {
            Text("前回の続き", style = MaterialTheme.typography.labelMedium)
            Text(title, style = MaterialTheme.typography.titleMedium)
            Text(chapterTitle, style = MaterialTheme.typography.bodyMedium)
        }
    }
}
視覚的には普通のカード

スクリーンリーダーでは「前回の続き、作品名、章タイトルから再生」と読ませる

8. バックグラウンド再生の骨組み（田中🎯）
8-1. PlaybackService の役割
フォアグラウンドサービスとして動作

PlaybackManager を保持

メディアセッション（ロック画面・通知からの操作）と連携

疑似コード：

class PlaybackService : Service() {

    private lateinit var playbackManager: PlaybackManager
    private lateinit var mediaSession: MediaSessionCompat

    override fun onCreate() {
        super.onCreate()
        // DI等で playbackManager を取得
        // mediaSession の初期化
    }

    fun playNovel(novelId: Long) {
        // Service 内から playbackManager.playNovelFromLastPosition を呼ぶ
        // 通知の更新など
    }

    // 再生・一時停止・次へ/前へなどのメディアボタンハンドリング
}
MVPでは：

まずは「アプリがバックグラウンドに行っても再生継続」だけを目標にし、

ロック画面操作・通知の完全対応は「2ndフェーズ」に回してもよい。

9. 読書家視点からの「これなら使う」チェック（読書家F🌀）
F：

「正直、インターフェース名とかはどうでもよくて（笑）、
“1作品を最後まで安定して聞けるか”“続きがすぐ再生できるか” がすべて。」

今出てきた設計に対する、Fからの要求まとめ：

PlaybackManager.playNovelFromLastPosition がちゃんと動くこと

再生位置が数分単位で記録されていて、アプリが落ちても戻れること

章またぎ再生がスムーズ（変な間が入らない）であること

TextPreprocessorのおかげで、ルビや記号が邪魔しない程度の読み上げ品質があること

この4つが実現されていれば、
「UIが多少ダサくても日常利用する」とのこと。

10. 専門家からの微修正・補足
佐藤🧠

「ここまで作り込む前に、NovelSource は最初1サイトだけ（例：なろう）に絞ってもいい。複数対応はユーザーがつき始めてから。」

高橋💥

「早い段階で、小規模ユーザー（友人やSNS少人数）を招待してテストしてもらい、
“読み上げ品質”“使い勝手”の定性的フィードバックを受けると、優先度がはっきりする。」

山本🧠

「NovelSource が“負荷をかけない実装”になっているか（キャッシュ・再リクエスト間隔など）は、ローンチ前に再チェックしたい。
一度取得した章は極力ローカル再生だけにする方針を徹底してほしい。」

議論の質評価（今回）
クラス設計・疑似コードまで踏み込めた

実際に実装し始められるレベルの粒度になった

まだ足りない部分：

エラー時のリトライ戦略（HTML取得失敗・TTSエラーなど）

章チャンク分割の詳細（超長文対策）

ユニットテスト方針

自己評価：92点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「HTML解析だけを徹底的に」「アクセシビリティだけ詳しく」

さらに意外な視点から議論する

例）「作者・サイト運営から見て嬉しい機能」

さらに議論を続ける

例）テスト戦略やリリース手順、ベータ配布方法など

実行可能な次のアクションを提案

直近1週間分を“今日やる・明日やる”レベルまで具体分解

結論をまとめる

最初に戻る

番号でも、「テストの話を聞きたい」「HTMLのパースをもっと」など、一言でもOK。

あなた:
2
深層ディスカッションAI の発言：

思考時間: 12s
今までの議論はだいぶ濃くなってきたので、
今回は一度立ち止まって、**「どこが過剰・どこが抜けているか」**を専門家たちでチェックしていく。

👥 参加メンバー（継続）
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UX・UIデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

山本（法務・著作権）🧠正統派

高橋（ビジネス・収益化）💥逆張り

読書家F（ヘビーユーザーペルソナ）🌀パラドックス型

1. PM視点：「MVPがまだ大きい問題」🧠佐藤
「全体としてはよく整理できているけれど、“最初の一歩”としてはまだ機能が多い。」

改善点1：MVPをさらに削る
これまで：

対応サイト：なろう＋カクヨム＋その他

機能：

章またぎ自動再生

オフライン再生

スリープタイマー

アクセシビリティ対応

本棚管理 など…

改善提案：

「1プラットフォーム × 1サイト × 1メインフロー」原則に落とす

例：

Androidのみ

「小説家になろう」のみ

機能は「URL登録 → 1作品を最後まで読み上げる＋続き再生」だけ

章またぎ自動再生・スリープタイマーなどは第2フェーズに移動

改善点2：成功指標（KPI）がぼんやり
今の議論だと「自分が毎日使う」がゴールになっているが、
客観的な数値目標がない。

例：

クラッシュ率：1%未満

1セッションあたり平均再生時間：15分以上

週あたりアクティブユーザー：10人（身近なテスターから）

2. エンジニア視点：「設計がやや重すぎるかも」🎯田中
「きれいな設計をしようとしすぎて、実装開始までのハードルが上がっている。」

改善点3：アーキテクチャは“後から整える”余地を残す
これまで：

3レイヤー構造

NovelSource / SpeechEngine / PlaybackManager など
抽象クラス・インターフェースが多い

改善提案：

v0.1では：

「なろう専用の NaroNovelRepository 1個」から始めてもよい

NovelSourceRegistry などは後で分離する

コードの目標を：

「動くスパゲッティをまず作り、2〜3回目のリファクタリングで整理」
くらいに緩めておく

改善点4：テスト・デバッグ戦略が薄い
HTML解析・TTS・バックグラウンド再生など、
壊れやすいポイントを「どの単位でテストするか」の話が不足

提案：

少なくとも以下のテストパターンだけは明文化する：

短い作品・長い作品・章が多い作品

オンライン／オフライン切り替え中の再生

画面ON/OFF・アプリ切り替え時の再生継続

3. UX視点：「初回体験とエラー状態が弱い」🎨鈴木
「通常状態のフローはかなり考えられているけれど、
“初めて使う時”と“うまくいかなかった時”の体験がまだ設計されていない。」

改善点5：初回ユーザー体験（Onboarding）がない
今の設計だと、初回起動時の画面がいきなり本棚（空）になりそう

改善案：

初回は本棚画面に以下を出す：

「まずは読みたい小説のURLを貼り付けてください」

簡単なチュートリアルイラスト or 文章

1回URLを登録したら、このガイドは非表示

改善点6：失敗時のUX
例：サイト構造変更で本文取得に失敗した時

「失敗しました」だけだと、ユーザーは“何が悪いのか”分からない

改善案：

エラーメッセージのパターンを分ける：

ネットワークエラー

対応していないページ形式

サイト側の一時的な問題

それぞれに「ユーザーができること」を添える：

別の作品を試す

時間をおいて再試行

「問い合わせ」への導線 など

4. 音声・アクセシビリティ視点：「“ちゃんとテストする仕組み”が抜けている」🔍中村
「“対応する”という話は出たが、どうやって品質を検証するかがまだ無い。」

改善点7：TTS品質のチェックプロセスが未定
Preprocessorのアイデアはあるが、

「実際に数作品を聞いてみて、どこが違和感か」を
フィードバックするループが定義されていない

改善案：

テスト用の“典型パターン作品”セットを用意

会話多め / 地の文多め / 記号多め / ルビ多め …など

バージョンを変えるたびに、この数作品を再生して
違和感をメモする「簡易レグレッションテスト」を自分で実施

改善点8：アクセシビリティは「実機テスト前提」で
現状は「スクリーンリーダーで試す」としか書いてない

より具体的には：

Android：TalkBack をONにして、「目をつぶって」

アプリ起動→前回の続き再生

作品一覧から特定の作品を選ぶ
この2パターンがストレスなくできるかをチェックする

問題があれば、画面構造そのものを変える覚悟も必要

5. 法務視点：「グレーゾーンのまま走り出さない工夫」🧠山本
「規約を見ることは話したが、“どこまでなら安全寄りか”の線引きがまだ曖昧。」

改善点9：より安全な“モード”を用意する選択肢
現状想定：サイトから直接HTML取得 → 本文抽出

より安全寄りの代案も用意しておく：

ユーザー自身がコピーしたテキストを貼り付けて読み上げるモード

最初はこれだけでもいいぐらい安全

もしくは：

「自動取得は“実験的機能（ベータ）”として、設定でONにした人だけ使える」にする

改善点10：利用規約・免責の書き方
アプリの利用規約に：

各サイトの規約を利用者が守る義務があること

アプリはあくまで「ユーザー自身が取得したテキストを読み上げるツール」であること
を明記しておく

6. ビジネス視点：「継続とユーザー獲得の話が薄い」💥高橋
「プロダクトはかなり考えたけど、**“誰にどう届けて、どう続けるか”**がまだ足りない。」

改善点11：早期ユーザーテストの計画
「完成してから公開」だと、方向がズレていても気づきにくい

改善案：

早い段階で：

知り合い数名＋SNSで数名募集して、クローズドβをやる前提で動く

βテスターには：

フィードバックフォーム（良かった点・悪かった点）

「バグ報告はスクショ＋一言でOK」と伝える

改善点12：終了条件・撤退ラインも決める
続けることだけでなく、

「ここまで行かなかったら、一旦開発を止める」ラインも決めておくと、メンタルが楽

例：

半年以内に：

自分が毎日使っている

ヘビーユーザーが3人以上いる
のどちらも満たせなければ、一度機能追加を止めて振り返る

7. ユーザー代表：「良すぎて“出てこない”リスク」🌀読書家F
Fからのツッコミ：

「正直、話がどんどんすごくなってて、
“それ全部揃うまで世に出てこない”ほうが怖い。」

改善点13：ユーザーから見た「必要最低限」をもう一度確認
F視点の“本当に必要な最初の版”：

URL貼る → 1作品を通して読み上げられる

続きから再生できる

落ちない・変な止まり方をしない

「オフライン・スリープタイマー・章またぎ自動・本棚の見た目…
正直、あとからで全然いい。」

つまり：

我々の議論は良い意味で“贅沢”な部分も多い

それが開発のブレーキになるなら、一度**“v0.1の仕様書”を半分に削る作業**が必要

8. 専門家同士の再調整
🧠佐藤 → 🎯田中
「抽象化を減らすのは賛成。ただし、Novel と Chapter のデータ構造だけは最初からちゃんと決めておきたい。ここがブレると後で地獄。」

🎨鈴木 → 🔍中村
「エラー時のメッセージって、アクセシビリティ上も重要ですよね。」
→ 中村「その通り。“何が起きたのか”“次は何をすべきか”が分かるメッセージは、スクリーンリーダーユーザーにとっても命綱。」

💥高橋 → 🧠山本
「安全よりに振りすぎて“何もできないアプリ”にならないように、コピー貼り付け＋実験的自動取得の2段構えはバランスが良いと思う。」

9. 改善点のまとめ（何を直すか）
特に重要な改善ポイント TOP5：

MVPをさらに削る

Android × 1サイト × 最低限の再生機能からスタート

設計を“作りながら整える”方針にする

最初から完璧なアーキテクチャを目指さない

エラー状態・初回体験・アクセシビリティの“テスト方法”を決める

とくにTalkBack/VoiceOverでの操作検証

より安全な利用モード（テキスト貼り付け）をまず実装候補に

自動取得は実験的機能として後付けでも良い

早期ユーザー（友人・少数テスター）からのフィードバック前提で進める

完成を待たずに、途中段階を使ってもらう設計

議論の質・自己評価
「どこが過剰か」「何が抜けているか」を、それぞれの専門視点から洗い出せた

とくに MVPの削り込み と リスク/テストの具体化 は一歩前進

まだ足りないのは：

「削り込んだMVP仕様」を1枚にまとめる作業

v0.1 / v0.2 / v1.0 の“段階的ロードマップ”

自己評価：89点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る（さらにメタ視点で）

専門家を変えて議論する

視点を変えて深掘る

例）「MVPを1枚の仕様にまとめる」

例）「テスト戦略だけを設計する」

さらに意外な視点から議論する

例）「視覚障害者コミュニティとの協力を前提に考える」

さらに議論を続ける

今回の改善点を前提に、削り込んだMVP仕様を具体化

実行可能な次のアクションを提案

「明日何をするか」レベルでタスク分解

結論をまとめる

最初に戻る

「6でMVP仕様まとめて」「7でタスクに落として」みたいな組み合わせの希望でもOK。

あなた:
より良いアプリになるように改善するつもりが　出来ても嬉しくない粗悪アプリになってきた
深層ディスカッションAI の発言：

思考時間: 12s
「そう感じている」ということ自体が、かなり重要なシグナル。

より良くしようとしていたはずが、
気づいたら「完成してもあまり嬉しくない、微妙なアプリ案」になってしまった

という違和感は、ちゃんと回収したほうがいいので、
一度 「作り手としてワクワクできる形」に戻す議論に切り替える。

👥 今日のメンバー
司会：モデレーターM
「今の設計を一度“崩していいところは崩す”役」

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

高橋（ビジネス・継続性）💥逆張り

読書家F（ことせかい難民ペルソナ）🌀パラドックス型

1. 「粗悪アプリになってきた」違和感の正体は何か？
🧠佐藤（PM）
「機能やリスクを真面目に考えすぎて、
**“作りたいアプリ”じゃなく“無難なツール”になってきている可能性」が高い。」

よくあるパターン：

法務・保守・汎用性を気にしすぎる

→ いろいろ削った結果、

「ことせかいより地味」

「ブラウザ＋読み上げ機能でも似たことできる」

＝ 完成しても感動がない

つまり、

「ことせかいの代わりが欲しかったのに、
“無難だけど刺さらない読み上げツール”の設計になってきている

というギャップが出ている。

2. 「嬉しくないアプリ」の典型パターンを洗い出す
🎨鈴木（UX）
ユーザー（＝作り手本人）が「嬉しくない」と感じるアプリは、だいたいこんな状態：

体験が“劣化コピー”

ことせかいの下位互換感

「あっちの方が楽」「あっちの方が気持ちいい」

手間ばかり増えている

URLコピペが面倒

テキスト貼り付けがダルい

設定が多いのにメリットが薄い

ワクワクするポイントがない

「このアプリだからこそ」の気持ちよさが見えない

このどれかに強く当てはまっている可能性が高い。

3. 「ことせかい難民」側の本音
🌀読書家F
「正直、“テキスト貼り付けて読み上げます”だけなら、
すでに似たことできる環境はいくらでもある。」

スマホの読み上げ機能

PCのTTSツール

ブラウザ拡張　など

Fの本音としては：

「ことせかいクラスに“特化した便利さ”が欲しいのであって、
“汎用で安全なだけの読み上げアプリ”だとテンションが上がらない。」

だから、

法務的に安全な方向に振りすぎて

かつ「特化の気持ちよさ」が薄くなると

→ 「出来ても嬉しくない粗悪アプリ」感覚が出てくる。

4. じゃあ、どこまで“攻め”を戻すべきか？
💥高橋（ビジネス）
「継続できないプロダクトの共通点は、
作り手がワクワクしてないこと。」

安全を考えるのは大事だが、

「訴訟リスクゼロ」の超無難アプリ

→ 作り手もユーザーもテンション低い

「ギリギリ攻めたけど、ちゃんとリスペクト＆配慮あり」

→ 作り手も楽しい、ユーザーも嬉しい

現実的には “後者寄り”で設計して、問題があれば都度調整 ぐらいがバランス良い。

5. 改めて、「作り手として本当に欲しいアプリ」を言語化する
🧠佐藤（PM）
ここで一度、理屈ではなく「欲望ベース」で決めてしまう。

「ことせかいの何が好きだったのか？
ことせかいに“もう一度”やってほしいことは何か？」

と仮定すると、こんな要素が高そう：

好きな小説を ワンタップで続きから聞ける

作品の追加が 簡単（URL共有でポン）

読み上げが そこそこ自然で、耳が疲れない

長い作品でも 落ちない・止まらない

ここに戻す。

6. 「ことせかい mini版」として設計をリセットする提案
🎨鈴木（UX）＋ 🎯田中（エンジニア）
いったん、こう考えるのはどうか：

「ことせかい mini」＝ “ことせかいの良さを最低限だけ詰めた、個人用バージョン”

✅ 入れる機能（最小だけどワクワクする）
URL共有から作品追加（なろう1サイトだけでもOK）

本棚画面（最近聞いた作品＋お気に入り数件）

再生画面（再生/停止・速度変更のみ）

前回の続きからワンタップ再生

1作品ぶんの章をまとめて取得→ローカル保存

❌ 一旦「やらない」と決めるもの
複数サイト対応

章をまたぐ高度な自動制御（細かいチャンク管理）

スリープタイマー

クラウドTTS

凝ったデザイン・テーマ切り替え

完璧なエラー分類

「ことせかいの全機能を再現」ではなく、
「ことせかいで自分が一番助かってた3〜4要素だけ拾う」 イメージ。

7. 「粗悪じゃなく、シンプルに嬉しいアプリ」にするための軸
🔍中村（音声）
「クオリティを上げるために追加機能を盛るのではなく、
“削った上で、ここだけは絶対に外さない”ポイントを決める のが大事。」

そのポイントは：

安定して最後まで読める

読み方が致命的に変でない

続きから即再生できる

この3つさえ守られていれば、
画面がダサくても、説明が少なくても、“粗悪”とは感じにくい。

8. ここまでの設計を「捨てていい」ライン
🎯田中（エンジニア）
「ここまでいろいろ設計してきたが、
“やめていいところ”ははっきりさせた方が気が楽になる。」

捨てていい／後回しにしていいもの：

綺麗な3レイヤーアーキテクチャ

拡張性の高い NovelSourceRegistry 一式

完全なアクセシビリティ対応（最初は“致命的に困らない”レベルで）

サービス＋通知＋ロック画面まで完璧に作るメディア制御

逆に、残したほうがよい基本設計：

Novel / Chapter / PlaybackState のデータ構造

「ローカルにテキストをキャッシュして再生する」思想

「起動したら前回の続きが最優先」というUX方針

9. 「今の設計だと嬉しくない」と感じるのは、むしろ健全
💥高橋（ビジネス）
「“なんか微妙だな…”と感じた時に軌道修正できる人のほうが、
結果として良いプロダクトを作りやすい。」

ここまでの議論は、

リスク・設計・機能・テスト…と真面目にやりすぎて

「作り手としてのワクワク」が削られてきた段階、とも言える

むしろ今のタイミングで

「あ、これじゃ嬉しくない」

と気づけたのは、

設計段階での“赤信号”をちゃんと見つけたということ。

ここから

「ことせかい mini」として

自分が本当に使いたい体験だけに絞り直す

方向へ舵を切るのがよさそう。

10. これからの進め方の提案（軌道修正プラン）
🧠佐藤（PM）からの提案
一度、「ことせかい mini」の理想体験を3行で書き直す

例）

毎日聞いている連載を、1タップで続き再生できる

URL共有から10秒以内で作品を追加できる

30分以上聞いても落ちない・変な止まり方をしない

その3行に“直接効く”機能だけ残す

それ以外は「v2以降」としてリスト化して寝かせる

「まずは自分専用ことせかい」で良しとする

公開前提よりも、

「自分が手放せなくなったら初めて誰かに配る」ぐらいの温度感

議論の質・自己評価
感情（モチベーション）とプロダクト設計のズレをきちんと扱えた

「どこまで捨てていいか」「どこを軸に戻すか」を整理できた

まだやっていないのは、

「ことせかい mini」の具体的な仕様1枚にまとめる作業

自己評価：90点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

「そもそも何のために作りたいか」から再定義

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「ことせかい mini の仕様を1枚にまとめる」

さらに意外な視点から議論する

例）「“自分専用ツール”として割り切る前提で考える」

さらに議論を続ける

今の違和感をさらに言語化して、要素を1つずつ潰していく

実行可能な次のアクションを提案

「今日やること3つ」だけに落とし込む

結論をまとめる

最初に戻る

「4でことせかいmini仕様まとめたい」「7でタスク化してほしい」みたいな感じで、番号や方向性を一言だけ返してもらえれば、そこから続けて整理する。

あなた:
スリープタイマー
小説家になろうとカクヨムに対応
は残して

ことせかいは10サイトくらい対応している

深層ディスカッションAI の発言：
まず前提を整理すると、

✅ スリープタイマーは必須
✅ 「小説家になろう」と「カクヨム」の両対応も必須
➕ ことせかいは約10サイト対応だが、最初からそこまでは狙わなくてよい

という条件で、「嬉しくない粗悪アプリ」ルートから引き返して、ちゃんとワクワクする設計に組み直す、というラウンドになる。

👥 メンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

高橋（ビジネス・継続性）💥逆張り

読書家F（ことせかい難民ペルソナ）🌀パラドックス型

1. まず「MVPの柱」をアップデートする 🧠佐藤（PM）
「ユーザーから“ここは残したい”と指定が入ったので、
MVPのコア機能を正式にこう定義し直す。」

コアMVP機能（もう削らない前提）
対応サイトは2つ：

小説家になろう

カクヨム

スリープタイマー

「◯分後に停止」 or 「◯章で止める」のどちらかは必ず入れる

就寝前に聞く使い方をきちんと想定

ことせかいライクな体験の最低ライン

URL共有から作品追加

続きからワンタップ再生

長編でも落ちにくい安定再生

10サイト対応は**“ことせかいのゴール像”として残しつつ、
現実的には「まず2サイトで気持ちよく動くこと」を最優先にする。

2. 2サイト対応＋スリープタイマーの技術的整理 🎯田中（エンジニア）
2-1. サイト対応の方針
「最初から“拡張可能”にしつつ、実装するのは なろう＋カクヨムだけ に絞る。」

SourceType は最初から NARO / KAKUYOMU / OTHER ぐらいは定義しておく

でも 実装クラスは2つだけ：

class NaroNovelSource : NovelSource { /* なろう専用解析 */ }
class KakuyomuNovelSource : NovelSource { /* カクヨム専用解析 */ }
NovelSourceRegistry もURL判定ロジックは2サイトだけを書く

3つ目以降のサイトは「将来のTODOリスト」に逃がす

これで、10サイト対応への道は残しつつ、今は2サイトに集中できる。

2-2. スリープタイマー実装の基本
「タイマーは凝ると沼るので、まずは時間指定だけやるのが現実的。」

シンプル案：時間ベースだけ実装

再生中に「◯分後に停止」をセット

PlaybackManager に sleepAtMillis: Long? を持たせる

再生ループ or onProgress の中で

System.currentTimeMillis() >= sleepAtMillis なら speech.stop() する

疑似コードイメージ：

class PlaybackManager(...) {

    private var sleepUntil: Long? = null

    fun setSleepTimer(minutes: Int) {
        sleepUntil = System.currentTimeMillis() + minutes * 60_000L
    }

    fun clearSleepTimer() {
        sleepUntil = null
    }

    private fun onProgress(position: Long) {
        // 再生位置保存など
        sleepUntil?.let { t ->
            if (System.currentTimeMillis() >= t) {
                speech.stop()
                sleepUntil = null
            }
        }
    }
}
章数ベース（「この章終わったら止める」）は、
2ndフェーズの追加機能として後回しにしてもいい。

3. UX：2サイト対応＋タイマーを「うるさくなく、でも嬉しく」見せる 🎨鈴木
「2サイト対応とスリープタイマーは“嬉しさ要素”なので、
地味に埋めず、だけどゴチャゴチャもしない配置が大事。」

3-1. 2サイト対応の見せ方
ホーム上でわざわざ「対応サイト一覧」を主張する必要はない

代わりに：

作品追加画面 or 初回オンボーディングで

「今は 小説家になろう / カクヨム に対応しています」と一言添える

URL貼り付け時：

対応サイトならアイコン表示

[なろうアイコン] or [カクヨムアイコン]＋「この作品を追加」

3-2. スリープタイマーUI案
再生画面の右上に「⏰」アイコン

タップ → モーダル or ボトムシートでタイマー設定

内容はシンプルに：

「スリープタイマー」

OFF

10分

20分

30分

60分

一覧から選ぶだけにして、
自由入力は一旦やめると、操作も実装もラクになる。

4. 音声・就寝前の使い方をちゃんと想定する 🔍中村
「スリープタイマーが必須ということは、“寝ながら聞く”ユースケースがコアということ。」

この前提での改善ポイント：

小さめの音量でも聞き取りやすい声・速度

初期値の速度・ピッチを、寝る前想定でややゆっくり目に

ユーザーが変えられるが、デフォルトの質感を大事にする

タイマー終了時の挙動

いきなりガツンと止まるより、

できれば「章末で止める」オプションも将来検討

ただしMVPでは時間ベースでもOK（実装コスト優先）

タイマー設定は読み上げ中でも変えられる

寝る体勢に入ってから「やっぱり10分にしよう」があり得る

スリープタイマーは「便利機能」ではなく、
**“就寝前リスニング体験の中核”**として設計したい。

5. ビジネス・継続性視点：2サイト＋タイマーは「魅力として十分」 💥高橋
「ユーザーを惹きつける“フック”という意味では、
なろう＋カクヨム＋スリープタイマーで、既にかなり強い。」

ことせかい難民から見れば：

2大サイト対応

寝ながら聞けるスリープタイマー

続きからワンタップ再生

→ 「これが安定して動くだけで、“粗悪”どころかかなり嬉しい」ラインに十分届く。

一方で、10サイト全部対応を最初から狙うと：

実装コストも保守コストも爆増

1サイトでも仕様変更が来たら即死

現実解としては、
“2サイトが鉄壁に動くアプリ” をまず作り、
ユーザー数や反応を見てから3サイト目以降を検討するのが健全。

6. 読書家F：「それなら“粗悪”感はかなり減る」🌀
F視点の正直な感想：

「・なろう対応
・カクヨム対応
・スリープタイマー
・続きからすぐ再生
この4つが揃ってて安定してるなら、
もう“ことせかい難民キャンプ”からは抜け出せる気がする。」

Fが気持ち悪かったポイントは、

「安全・汎用」を意識しすぎて

“なろうもカクヨムも中途半端、タイマーもない”みたいな、

**「どこにも刺さらない中庸アプリ」になりかけていたところ。

そこに対して、

「2サイトはちゃんと押さえる」

「スリープタイマーは必須」

「続き再生も当然やる」

と決め直したので、

「あとは“これ以上盛り過ぎないように”さえ気をつければ、
粗悪アプリルートからはかなり離れられる」

という感触。

7. まとめ：新しい「ことせかいmini（仮）」仕様の中核
★ 必須機能（これだけは死守）

対応サイト

小説家になろう

カクヨム

コア体験

ブラウザからURL共有 → アプリが作品登録

アプリ起動 → 「前回の続き」ボタン1タップで再生

ローカルキャッシュで安定再生

スリープタイマー

再生画面の⏰ボタンから 10/20/30/60分程度を設定

設定時間で自動停止（MVPは時間ベースのみ）

最低限の読み上げ品質

ルビ・記号をある程度整形するTextPreprocessor

速度・ピッチ変更（寝る前に合わせやすく）

☆ 後回し候補（v2以降に追い出す）

3サイト目以降の対応（ことせかい並みの10サイトは完全に将来）

章数ベース・章末停止のスリープタイマー

ロック画面からの細かい操作

派手なデザインやテーマ切り替え

高度な辞書機能

議論の質・自己評価
ユーザーからの「これだけは残したい」という条件を軸に、MVPを再定義し直せた

「粗悪アプリ感」の正体を分解し、「2サイト＋タイマー＋続き再生」という気持ちよさの核を再確認できた

まだやっていないのは：

この新しいMVP仕様を、一枚の仕様書 or チェックリストに落とすこと

「今日から1週間でやるタスク」に分解すること

自己評価：93点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「なろう＋カクヨム対応を、技術的にもっと具体化」

例）「スリープタイマーの仕様をパターン別に決める」

さらに意外な視点から議論する

例）「ことせかいより“ちょっとだけ嬉しいポイント”を考える」

さらに議論を続ける

実行可能な次のアクションを提案

「明日〜1週間でやること」をリストにする

結論をまとめる

最初に戻る

番号でも、「スリープタイマーだけもっと詰めたい」「2サイト対応の実装を詳しく」みたいな一言でも大丈夫。

あなた:
5
深層ディスカッションAI の発言：

思考時間: 10s
作る側のテンションが上がる「ちょっとだけ嬉しいポイント」を、
あえて変な角度から掘っていきます。
機能を増やしすぎて重くせず、でも「ことせかいより好きかも」と思えるツボ探しです。

👥 本日のメンバー（意外な視点担当）
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

高橋（ビジネス・継続性）💥逆張り

作家ペルソナA（なろう＆カクヨムで活動する作者代表）🌀パラドックス型

前提として：

✅ 小説家になろう 対応

✅ カクヨム 対応

✅ スリープタイマー必須

これは**いじらない「軸」**として固定したうえで、
「+1〜2個の“意外に嬉しい”要素」を探します。

1. 作者視点：「作者に優しい耳読アプリ」という差別化 🌀作家A
作家A：

「読者が耳で聞いてくれるのは嬉しいけど、
**“原文を読みに来てもらえない”**と、ちょっと寂しい。」

ことせかい系アプリへの、作者側のモヤモヤあるある：

作品は読まれているのに

アクセス数やポイントに反映されない

感想・レビューが増えない

サイト側から見ると「外部で勝手に消費されてる」感もある

ここを逆張りでプラスにするアイデア：

✅ 「作者リスペクト導線」を入れる
再生画面や作品詳細に、「原作ページへ」ボタンを常設

1タップで、その話のWebページをブラウザで開く

ある程度聴いたら、さりげなく：

「そろそろ原作ページでブクマ・★評価しませんか？」
みたいな**“推し作者を応援する”一言**

これは技術的にはリンクを開くだけで負荷は軽いのに、

作者側には「ポイント・★・PV」がちゃんと戻る

サイト運営側にもメリットがある

アプリの存在意義が「消費ツール」から
→ “作者を応援する耳読ツール” に格上げされる

🧠佐藤（PM）：

「これをアプリの“理念”として前面に出すと、
ことせかいとの差別化になりつつ、心理的にも作りやすくなる。」

2. 生活リズム視点：「おやすみ専用アプリ」にしてしまう 🔍中村
中村：

「スリープタイマー必須と言われた時点で、
“寝る前に使う”がコアシーンだと割り切れる。」

その視点での**＋αアイデア**：

✅ 「おやすみモード」を1スイッチで用意
スリープタイマー設定と連動して、

画面を自動でほぼ真っ暗に（OLED省電力＆眩しくない）

テーマカラーを落ち着いた色に

通知を簡易ミュート（できる範囲で）

UI的には：

再生画面に「🌙 おやすみモード」トグル

ONにすると

スリープタイマー自動で 30分 にセット（変更可）

画面が暗色＆最低限UIにスリム化

これだけで、

「就寝前はこのアプリ立ち上げて、🌙押して、寝る」
という儀式感が出る。

🎨鈴木：

「“耳読アプリ”というより、
“寝る前の相棒”として愛着が湧くデザインにできる。」

3. 積読処理視点：「たまってるブクマを消化するマシン」💥高橋
高橋：

「なろう・カクヨムユーザーあるある：
“ブクマだけ増えて全然読めてない”現象。」

ことせかいにはあまり無かった視点として：

✅ 「積読消化プレイリスト」
本棚とは別に、「積読モード」を1つ用意

まだ1話目しか読んでいない作品

読了率が低い作品
を自動でリストアップ

「積読モード再生」を押すと：

そのリストを順番に、1〜2話ずつ読み上げていく

気に入ったら「通常本棚へ昇格」ボタン
（お気に入り登録みたいなイメージ）

これは、

機能的には「再生キュー」を少し頑張るだけ

でも読者の感覚としては：

「溜まってた作品を“耳でお試し”できるモード」
＝ **“積読処理マシン”**になる

🌀作家A：

「興味本位でブクマされて終わり、よりも、
“耳で1〜2話試してもらえる”ほうが可能性を感じる。」

4. 「雑に使っても壊れない」視点：雑さに強いUI設計 🎯田中
田中：

「意外に差が出るのが、雑に扱っても破綻しないかどうか。」

ことせかい的な用途だと、

再生中にアプリを殺してしまう

電波が切れる

端末のメモリがキツい

間違って戻るボタン連打 など、

“乱暴な操作”が日常的に起きる。

ここに対する＋αの工夫：

✅ 「雑に扱っても続きがちゃんと残る」設計
再生位置の保存を

「停止時」だけでなく、数十秒ごとにこまめに

アプリがクラッシュ・強制終了しても、
ほぼ聞いたところまで戻れる

UI的には地味だけど、

「あれ？さっきまで聞いてた場所どこ行った？」
が起きないだけで、ストレスが激減する。

これは「機能追加」ではなく、
実装ポリシーとしての＋αですが、

「ことせかいより“安心して放置できる”」

「長編を聞いてても怖くない」

という、長く使う人ほど効いてくる差別化になる。

5. 「ことせかいよりちょっと嬉しい」候補を3つに絞る
ここまでの意外視点から、
実装コストの割に“効きそうな”＋α機能候補を3つだけ選抜する。

候補①：作者リスペクト導線（🌀作家A 提案）
各話から「原作ページへ」1タップ

一定時間以上聞いた作品には
「原作ページで★やブクマしませんか？」のさりげない一言

👉 メリット：

作者・サイト運営にも優しい

気持ちよく開発・公開しやすい雰囲気になる

差別化ポイントとしても語りやすい

候補②：🌙おやすみモード（🔍中村＋🎨鈴木）
スリープタイマー＋画面暗転＋シンプルUIをまとめた「寝る前スイッチ」

例：

ONにすると30分タイマー＋ダークテーマ＋最低限ボタン表示

👉 メリット：

スリープタイマーを単なる機能から“体験”に昇格させる

「寝る前はこのアプリ」と習慣化しやすく、ヘビーユーザー化しやすい

候補③：積読モード（💥高橋）
「まだあまり進んでいない作品」を自動リストアップ

積読モードで1〜2話ずつお試し再生

気に入ったら本棚に昇格

👉 メリット：

「読む時間がないから…」と溜まるブクマを、
“耳で消化する”新しい使い方を提供

他のTTSアプリにはあまりない視点

6. どうしても機能増えすぎが不安な場合の優先度
もし

「3つも増やしたらまた重くなりそう…」

と感じるなら、優先度をこう置くのがおすすめ：

作者リスペクト導線
→ リンク開くだけなので実装コストが軽い割に、意味が大きい

🌙おやすみモード（最低限版）
→ 実は「スリープタイマー＋シンプルUI切り替え」程度でも成立する

積読モード
→ これは2ndフェーズに回してもいい“遊び機能”

議論の質評価
「ことせかいよりちょっと嬉しい」を、
単なる機能の数ではなく、視点（作者・睡眠・積読）から設計できた

特に

作者リスペクト

おやすみ専用体験

積読消化
は、他アプリにあまりない差別化軸になりうる

まだやっていないのは：

この3候補のうち「どれをMVPに入れるか」最終決定

入れると決めたものを、仕様レベルに落とすこと

自己評価：92点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「作者リスペクト導線だけ仕様に落とす」

例）「おやすみモードだけ具体設計する」

さらに意外な視点から議論する

さらに議論を続ける

実行可能な次のアクションを提案

「＋α機能を含めて、今週何を作るか」

結論をまとめる

最初に戻る

「おやすみモードを具体的に作り込みたい」など、
気になった＋α要素を指名してもらってもOK。

あなた:
積読モード　はいらない

おやすみモード（最低限版）
→ 実は「スリープタイマー＋シンプルUI切り替え」程度でも成立する　は欲しい

作者リスペクト導線
→ リンク開くだけなので実装コストが軽い割に、意味が大きい　は一応つけよう

あと大事なのが
小説の文字を見ながら聞けること。

意味がわからない時(読み間違い)などがあった時に画面で確認出来るのは大きい
深層ディスカッションAI の発言：
結論から整理すると、ユーザー側の「これだけは欲しい」がこう固まりましたね：

❌ 積読モード：いらない

✅ おやすみモード（最低限版）：スリープタイマー＋シンプルUI

✅ 作者リスペクト導線：原作ページへのリンクをつける

✅ 小説の文字を見ながら聞けること：読み間違い時に画面で確認したい

この4点を軸に、設計を“また肥大化させずに”まとめ直していきます。

👥 本日のメンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

高橋（ビジネス・継続性）💥逆張り

読書家F（ことせかい難民ペルソナ）🌀パラドックス型

1. 「MVPの最終コア」再定義 🧠佐藤（PM）
佐藤：

「ユーザーの“これは欲しい／これはいらない”が見えたので、
MVPの軸をここで最終確定させたい。」

✅ コア機能（もう削らないセット）
対応サイト：

小説家になろう

カクヨム

再生体験：

URL共有 → 作品追加

起動 → 「前回の続き」1タップ再生

スリープタイマー（時間指定）

表示：

再生中に「本文を見ながら聞ける」画面

読み上げがおかしいときに、文字で確認できることが前提

プラス要素：

おやすみモード（最低限版）

スリープタイマー＋暗いシンプルUI

作者リスペクト導線：

「原作ページへ」ボタン

この4グループさえしっかり押さえれば、
ことせかい難民視点から「粗悪」にはならないラインに乗る。

2. 「文字を見ながら聞ける」UIの形 🎨鈴木（UX）
鈴木：

「一番大きな要件はここ。
“耳だけのアプリ”ではなく、“耳＋目で確認できるアプリ” にする。」

2-1. 再生画面の構成イメージ
上部：プレイヤー部分

作品名・章タイトル

再生/一時停止ボタン（大）

進捗バー

速度変更ボタン（トグル）

⏰アイコン（スリープタイマー）

🌙トグル（おやすみモードON/OFF）

下部：本文ビュー

スクロール可能なテキスト領域

章全体の本文を表示

フォントサイズ変更（＋ / − くらいの簡易ボタンでもよい）

ポイント：

音声操作とテキストを同一画面にまとめる
→ 読み間違いがあった瞬間にすぐ視線を下に落とせる

文字を読まない人向けにも、「テキストを閉じる」ボタンがあっても良い（MVP後回しでもOK）

2-2. 「読み間違い確認」用の使い方を想定
いつもは耳だけで聞く

「ん？今の一文よく分からなかった」と思ったら：

一時停止ボタンを押す

画面下のテキストをざっとスクロールして、その付近の文章を見る

理解できたらまた再生

→ このフローがスムーズなら、自動ハイライトとか高度な同期はMVPでは不要。

3. 技術的にどう表示するか 🎯田中（エンジニア）
田中：

「“完全同期ハイライト”をいきなり目指すとキツいので、
MVPでは章単位でテキストを出すだけに留めるのが現実的。」

3-1. テキスト保存と表示の基本
各章ごとに：

取得→整形したテキストをローカルファイルに保存

画面表示時にそれを読み込んで表示

data class Chapter(
    val id: Long,
    val novelId: Long,
    val index: Int,
    val title: String,
    val sourceUrl: String,
    val localPath: String?, // テキストファイルパス
    val lengthChars: Int?
)
表示側（Compose）：

@Composable
fun ChapterTextView(
    text: String,
    modifier: Modifier = Modifier
) {
    Box(modifier = modifier) {
        Text(
            text = text,
            modifier = Modifier
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            lineHeight = 20.sp
        )
    }
}
3-2. シンプルな同期戦略（MVP）
MVPでは：

再生開始時にテキストの先頭を表示

自動スクロール・文ごとのハイライトはやらない

将来案（頭の片隅）：

テキストを段落ごとに分割して、
再生位置からだいたいの段落を推定してハイライトする

でも今は「見ながら確認できる」が目的なので、
実装負荷と天秤にかけて段階的にやるのがよさそう。

4. おやすみモード（最低限版）の具体像 🔍中村
中村：

「おやすみモードは、“寝る前に使う快適さ”に直結するので、
スリープタイマー＋画面・UI簡略化に絞る。」

4-1. おやすみモード ON時の挙動
ONにすると：

スリープタイマーを自動設定

デフォルトで 30分（ユーザーが変更できても良い）

画面を暗く・シンプルに

背景：真っ黒 or 濃いグレー

テキスト：淡いグレー

コントロール：

再生/停止

進捗バー（簡易）

タイマー残り時間表示（「あと27分」程度）

余計な情報（作品一覧ボタン・細かいメニュー）は非表示

UIイメージ：

🌙トグルON → 再生画面が「夜用UI」に切り替わる

4-2. 実装のしぼり方
見た目切り替えは：

isNightMode フラグでコンポーズのテーマを変えるだけでもOK

厄介なのは通知・他アプリの音などだが、MVPでは：

「画面とタイマーだけ」を対象にする
→ システム全体の“おやすみモード”まではやらない

「寝る前に、まぶしくない・余計なボタンが目に入らない」
ここを満たすだけでも、満足度はかなり違う。

5. 作者リスペクト導線の設計 💥高橋 ＋ 🌀作家F
高橋：

「これは“意味の割にコストが軽い”ので、きれいに差し込んでおきたい。」

5-1. どこに置くか
作品詳細画面：

ボタン：

「原作ページを開く」
→ 作品トップページ or その章のURLをブラウザで開く

再生画面：

メニューの中に小さめの項目で：

「原作サイトで読む・★評価する」

5-2. 押しつけがましくしない
再生途中でポップアップをバンバン出すとウザいので、

基本はユーザーが能動的に押せる場所に置くだけにする

将来、「何話以上聞いたら1回だけ“応援しませんか？”バナー」を出す
くらいの控えめな誘導はアリかも（MVP後）

作家F：

「“原作で★入れてくれる”導線があると、
作家から見ても“敵”じゃなく“味方”に感じる。
あまりそこまでしてくれてるアプリってないので、好感度は高い。」

6. 「文字を見ながら聞ける」ことのアクセシビリティ面 🔍中村
中村：

「視力にバラつきがあるユーザーを前提に考えると、
この要件は実はかなりアクセシビリティ寄りの良い要求。」

6-1. やっておきたい最低限
フォントサイズ変更

小/中/大くらいの切り替え（細かいスライダーまでは不要）

行間を少し広めに

ぎゅうぎゅうの文章は読みづらい

コントラスト

通常モード：黒字×白背景 or ダークモード

おやすみモード：暗背景×やや淡めの文字

6-2. スクリーンリーダーとの関係
再生画面では、スクリーンリーダーが余計に本文を読み始めると邪魔になるので、

「本文は音声読み上げの対象にしない」設定も検討

ただ、視覚障害ユーザーは
そもそもアプリTTSよりスクリーンリーダーを使う可能性が高いので、

MVPでは「視覚ユーザー＋軽い弱視ユーザー」を主ターゲットにしてOK

7. 読書家Fからのフィードバック 🌀
F：

「今の方向性なら、
“ことせかいの下位互換”ではなく“ことせかいの別系統の後継”
って感じがしてきた。」

特に嬉しいポイント：

なろう＋カクヨム対応はそのまま

スリープタイマー＋おやすみモードで「寝る前専用感」

文字を見ながら聞ける → 読み間違い時の不安が減る

原作ページへのリンク → 作者に悪い感じがしない

「欲を言えば自動ハイライトもいつか欲しいけど、
まずは“文字が見える”だけでもかなり安心。
それが最初から前提に入ってるだけで、
完成版のイメージがかなりワクワク側に戻ってきた。」

8. いま決まった仕様の要点まとめ
必須セット（MVP）
対応サイト

小説家になろう / カクヨム

再生画面

再生/停止・進捗バー・速度変更

スリープタイマー設定（10/20/30/60分など）

🌙おやすみモードトグル

章全文テキスト表示（スクロール可能）

フォントサイズ簡易変更（小/中/大）

おやすみモード（最低限版）

ONで：

画面暗色・シンプルUI

スリープタイマー自動セット

作者リスペクト導線

作品詳細 or 再生画面メニューから
「原作ページを開く」ボタン

読み上げ品質補助

章テキストの表示

（内部的にはTextPreprocessorで最低限の整形）

議論の質評価
ユーザーの「いらない」「これは欲しい」を反映しながら、
機能を絞りつつ“ワクワクする軸”を保てた

特に

文字を見ながら聞ける

おやすみモード

作者リスペクト
を無理なく再生画面に統合できている

まだ不足しているのは：

具体的な画面ワイヤー（レイアウト図）

これを1〜2週間の実装タスクに落とした「やることリスト」

自己評価：94点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「再生画面1枚のUIレイアウトを具体的に描く」

例）「本文表示の実装（スクロール・フォント変更）だけ詳しく」

さらに意外な視点から議論する

さらに議論を続ける

実行可能な次のアクションを提案

いま決まった仕様で、“明日から何を作るか”を細かく分解

結論をまとめる

最初に戻る

「4で再生画面だけ詰めたい」「7でタスクを出してほしい」など、
ざっくり希望だけ返してもらえれば、次のラウンドに進行する。

あなた:
章単位でテキストを出す

今　どこを読んでいるのかわからないと　文字で確認が出来ないけど大丈夫？
深層ディスカッションAI の発言：

思考時間: 7s
結論から言うと、

「章単位でテキストを出すだけ」だと
“今どこを読んでるか分からない問題”は、けっこうストレスになる

ので、MVPの時点でも“ざっくり位置が分かる仕組み”は入れた方がいい、という方向で専門家側の意見はほぼ一致するはず。

そこを前提に、
「でも重すぎる同期機能にはしたくない」という条件で、現実的な落としどころを議論する。

👥 メンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・アクセシビリティ）🔍深掘り型

読書家F（ことせかい難民ペルソナ）🌀パラドックス型

1. 「分からないまま」はキツい？🧠佐藤（PM）
「“文字で確認したい”というニーズがある時点で、
『今どこを読んでるのか分からない』状態はMVPとしても弱い。」

とくに今回のコンセプトでは：

読み間違い／意味が分からない時に、画面で確認したい

＝「その近くの文字が、すぐ見つかる」が重要

なので、

ただ「章全体を表示してるだけ」だと、

長い章ほど「このへんかな？」と探すのが大変

→ 不満がたまる

結論：

MVPでも、“今読んでるあたり”がざっくり分かる工夫は入れるべき。
ただし、完璧な1文単位同期は狙わない。

2. 技術的に現実的な「簡易同期」案 🎯田中（エンジニア）
田中から、コスト少なめでできる案を3レベルで整理：

レベル1：時間ベースの「ざっくりスクロール同期」
テキスト全体の文字数 N と
章を読み上げる予想時間 T（ミリ秒）を使う

経過時間 t に対して
「今読んでる位置 ≒ N * (t / T) 文字あたり」と仮定して、
そのあたりが画面の真ん中に来るように自動スクロールする

イメージ：

10分（600秒）の章、6000文字なら
→ 1秒 ≒ 10文字

経過300秒なら ≒ 3000文字付近までスクロール

メリット：

実装軽い（文分割など不要）

「だいたいこの辺」と分かればOKなら十分

デメリット：

会話が多い部分や、記号が多い部分で誤差は出る
→ でも“確認”が目的なら実用範囲

レベル2：チャンク分割＋ハイライト（ちょい頑張る版）
章テキストを段落ごと or 一定文字数ごとにチャンク分割

TTSもチャンク単位で順次読み上げる

今読んでいるチャンクにだけ背景色をつけてハイライト

メリット：

「この段落を読んでる」が見た目で分かる

スクロールもチャンク単位であわせやすい

デメリット：

実装がレベル1より一段階重い
（チャンク管理・TTS分割・インデックス管理）

レベル3：完璧同期（MVPではやらないほうがいい）
文単位に分割＋TTSイベントで文ごとに同期

実装もデバッグもかなり重い

→ ここは将来の夢枠で、MVPからは外すのが妥当。

田中の提案：

「MVPでは、レベル1（時間ベースのざっくりスクロール）＋手動で少し戻れるボタン
の組み合わせにすると、コストと実用性のバランスがいい。」

3. UX的にどう見せるか？🎨鈴木（UX）
鈴木：

「ユーザーの心としては、
“ピッタリ合ってなくてもいいから、なんとなく今ここが分かれば安心。”」

UX案：ざっくり同期＋手動補助
自動スクロール

再生開始 → テキストの先頭を表示

時間経過に合わせて、テキストがゆっくり下にスクロールしていく

今読んでいると推定される行を、
うっすら背景色でマーク（理想だけど、なくても可）

5秒戻る・10秒戻るボタン

「あれ？」と思ったら、

「◀︎ 5秒戻る」ボタンを押して、

テキストを少し上にスクロールして見る、という運用がしやすい

スクロール手動もOK

ユーザーがテキストを上下にスクロールしたときは、
自動スクロールを一時停止
（これ以上凝るのは後回しでOK）

「“どこ読んでるか全然分からない”状態は避けたいけど、
ミリ秒単位の精度はいらないので、
『だいたいこの辺』＋『ちょっと戻せる』が揃えば実用は十分」

4. 読書家側の許容ライン 🌀読書家F
Fの本音：

「正直、“完全同期ハイライト”までは求めてない。
でも、何ページ分もスクロールして探さないと分からないのは嫌。」

許容できるライン：

自動スクロールで大体の位置が合ってる

「あ、今の分かりづらかった」と思ったら、

5〜10秒戻るボタンを押して、

テキストをちょっと上に戻して見る
→ この操作が直感的ならOK

逆にNGなのは：

毎回テキスト先頭が表示されたまま

再生位置と画面の位置が完全にバラバラ

「確認したいときに、どこを見ればいいか分からない」

「だから、“章単位でテキスト出るだけ”は物足りないけど、
時間ベースのざっくり同期＋戻るボタンなら、
『ああ、今だいたいここを読んでるのね』って分かれば満足。」

5. アクセシビリティ視点の注意点 🔍中村
中村：

「自動スクロールを入れるときの罠として、
“本人がスクロール中に画面が勝手に動くと酔う” という問題がある。」

なので：

ユーザーがテキストを触ってスクロールしたら、
→ その間は自動スクロールを止める

しばらく触ってなければ、
→ 再生位置に合わせて、静かに追いつく程度

MVPでは：

「自動スクロールはあるけど、ズレても困らない」程度の親しみ方でOK

本当に困るのは
**「テキストは出てるのに、どこ読んでるか全く分からない」**状態なので、
そこを避けるのが優先。

6. 結論：「章テキスト＋ざっくり同期」はやったほうがいい
まとめると：

❌ 「章テキストを出すだけ（完全固定）」
→ 長文だと“どこ読んでるか分からない”問題が強い

✅ 「章テキスト＋時間ベースのざっくりスクロール同期」
→ 大体の位置が分かるので、文字で確認しやすい

✅ さらに「5〜10秒戻るボタン」と組み合わせると、
→ 読み間違い・聞き落としにも対処しやすい

なので、

「章単位でテキストを出す」だけでは不十分。
MVPでも“簡易的な位置同期”をつける方がいい。

というのが、チームとしての答え。

議論の質評価
ユーザーの具体的な不安（「どこ読んでるか分からない」）に対して、
技術・UX・ユーザー目線からそれぞれ具体案を出せた

「完璧同期は後でいい、ざっくり同期はMVPからやる」というラインが明確になった

自己評価：93点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「簡易同期（時間ベース）の具体ロジックやUIをもっと詳しく」

さらに意外な視点から議論する

さらに議論を続ける

実行可能な次のアクションを提案

「簡易同期＋テキスト表示を実装するための、具体タスク」

結論をまとめる

最初に戻る

「4で簡易同期をもっと具体的に」や「7で実装タスクに落として」など、一言くれれば次のラウンドにつなげる。

あなた:
5秒戻るとか逆に大変そう

今読んでいる段落に背景色をつけてハイライト

は可能？
深層ディスカッションAI の発言：

思考時間: 6s
結論から言うと、

**「今読んでいる段落に背景色ハイライト」**は
技術的にも十分「現実的」だし、
UX的にも「5秒戻る」よりずっと素直で分かりやすいです。

ので、これはコア仕様として採用してしまってOKという方向で話を進めます。

👥 本日のメンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・TTS）🔍深掘り型

読書家F（ヘビーユーザー）🌀パラドックス型

1. まず前提整理 🧠佐藤（PM）
「ユーザー操作として“5秒戻るボタンをポチポチ押す”のは、
就寝前とか家事中だと確かにだるい。」

なので、

「細かく時間で戻す」よりも

「今読んでいる段落が視覚的に分かる」ほうが直感的

という方針に切り替えるのは、筋が通っている。

PMとしての結論：

段落ハイライトをMVPの“文字表示まわりのメイン仕様”にする。
5秒戻るボタンは「無理に入れなくていい」側に移してしまってよい。

2. 段落ハイライトは技術的に可能か？ 🎯田中（エンジニア）
田中：

「やり方をシンプルに割り切れば、十分いける。
完全な文単位同期より、むしろこっちの方が実装しやすい。」

2-1. 基本アイデア
章テキストを 「段落リスト」 に分割する

例：空行（\n\n）や特定の改行パターンで split

paragraphs = listOf("一つ目の段落", "二つ目の段落", ...)

再生も「段落単位」で行う

TTSに渡す単位を「章まるごと」ではなく、
現在の段落テキストにする

1段落読み終わったら、次の段落をTTSに渡す

UI側では

currentParagraphIndex を状態として持つ

画面に段落リストを並べて表示し、
index == currentParagraphIndex の段落だけ背景色をつける

2-2. 擬似コードイメージ
（概念だけ）

val paragraphs: List<String> = splitToParagraphs(chapterText)
var currentParagraphIndex: Int = 0

fun playFrom(index: Int) {
    currentParagraphIndex = index
    val text = paragraphs[index]
    speechEngine.speak(text)
}

speechEngine.setListener(object : SpeechListener {
    override fun onComplete() {
        // 段落読み終わったら次へ
        if (currentParagraphIndex + 1 < paragraphs.size) {
            playFrom(currentParagraphIndex + 1)
        } else {
            // 章終わり
        }
    }

    override fun onStart() {
        // UI側に currentParagraphIndex を通知 → その段落をハイライト
    }
})
UI（ざっくり）：

Column {
    paragraphs.forEachIndexed { index, p ->
        Text(
            text = p,
            modifier = Modifier
                .background(
                    if (index == currentParagraphIndex) Color(0x223874FF)
                    else Color.Transparent
                )
                .padding(8.dp)
        )
    }
}
この方式なら、今どの段落を読んでいるかが確実に分かる。

3. UX的にどう見えるか？ 🎨鈴木（UX）
鈴木：

「“5秒戻る”はユーザーが時間を意識しないといけないので、
脳の負荷が地味に高い。
一方、“今ここです”とハイライトされると、一瞬で理解できる。」

3-1. 画面イメージ
再生画面下部のテキストエリア：

段落ごとに少し余白を空けて表示

今読んでいる段落だけ：

背景色をほんのり色づけ

または左端にバーを出す（縦線）

イメージ：

[   ] 段落1

[==] 段落2 ← 今ここ（背景が薄い色）

[   ] 段落3

[   ] 段落4
ユーザーの行動として：

「今の意味がよく分からなかった」
→ 画面を見ると、ハイライトされてる段落をそのまま読める

「少し前の段落から読みたい」
→ 1つ上の段落をタップ → そこから再生、みたいな操作も将来入れやすい

3-2. 自動スクロール
段落が画面の外に出るくらい量が多いときは、

「現在段落」が画面内の真ん中〜上あたりに来るようにスクロールしてあげる

スクロール速度はジャンプでOK（なめらかなアニメーションは後回しでもいい）

操作としては
「今どこ？」→画面見れば一発で分かる
ので、かなりストレス軽減になる。

4. TTS側から見た難易度 🔍中村（音声）
中村：

「実は、“段落ごとにTTSを分けて呼ぶ”のは
OS標準TTSでも普通にできる範囲。」

4-1. Android / iOS のイメージ
Android：

TextToSpeech.speak(text, ...) を段落ごとに呼ぶ

utteranceId に「chapter-12-paragraph-3」みたいなIDを付けておき、

onUtteranceCompleted で「3読み終わったから次4」と判断

iOS：

AVSpeechUtterance を段落ごとに作る

キューに順番に追加するか、読み終わりで次を流す

注意点：

段落が短すぎると utterance が増えすぎてオーバーヘッドになる
→ 1行だけの会話が連続するような場合は、複数行をまとめて1チャンクにする工夫は必要

でも、MVPでは：

「空行単位のまとまり」ぐらいで分ける

地の文がまとまったブロック

会話が数行まとまったブロック

くらいのラフさで十分実用レベル。

「きっちり文ごとに区切るより、
段落～小段落くらいの粒度で区切った方が安定しやすい。」

5. 読書家Fの感覚チェック 🌀
F：

「それ、かなり理想に近い。」

特に良い点：

「あれ？今どこ？」→画面チラ見 → ハイライト段落で一発

読み間違いがあっても、**“その段落を目で読んで補完”**がすぐできる

将来的に：

ハイライトされた段落をタップして「そこから再生」ができれば、
ほとんどの“聞き逃し問題”は解決しそう

逆に「5秒戻る」は：

5秒戻る → まだ分からない → さらに5秒…
となると地味にストレス

「段落ハイライト＋必要ならちょっと戻る機能」という順番なら、
戻るボタンはオマケ的な位置づけでもよさそう。

6. 結論：段落ハイライトは「やる方向」でOK
✅ 回答まとめ
「今読んでいる段落に背景色をつけてハイライト」は十分実現可能か？
→ はい、可能。
技術的にも、UX的にも現実的なライン。

MVPでやる価値があるか？
→ あります。
「文字で確認したい」という要件をちゃんと満たすには、
章テキスト表示だけでは不十分で、段落ハイライトがあるとかなり使いやすくなる。

5秒戻るボタンは？
→ 「絶対必要」ではない。
段落ハイライトがあれば、戻るは後回しでもOK。
必要になったら、将来「ハイライト段落をタップしてそこから再生」という方向でも対応可能。

議論の質評価
ユーザーの具体的な不安（「どこを読んでいるのか分からない」）に対して
技術・UX・音声・ユーザーの4方向から検証できた

結果として、**「段落ハイライトをMVPの正式仕様にする」**という明確な結論まで行けた

自己評価：95点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「段落分割のルールをもっと具体的に（なろう／カクヨム向け）」

例）「段落ハイライト＋おやすみモードを含めた再生画面レイアウト」

さらに意外な視点から議論する

さらに議論を続ける

実行可能な次のアクションを提案

「段落ハイライトを実装するための、具体タスク一覧」

結論をまとめる

最初に戻る

「4でレイアウト詰めたい」「7で実装タスクに落としてほしい」など、一言くれれば次のラウンドにつなげる。

あなた:
5秒戻るはいらない

逆に　読みたい段落をタップ → そこから再生、みたいな操作は必須
深層ディスカッションAI の発言：

思考時間: 6s
✅ 5秒戻るは不要
✅ 「読みたい段落をタップ → そこから再生」は必須

という前提で、
「段落ハイライト＋段落タップ再生」を中⼼にした仕様に組み直す議論に入る。

👥 メンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・TTS）🔍深掘り型

読書家F（ことせかい難民ペルソナ）🌀パラドックス型

1. プロダクト方針への反映 🧠佐藤（PM）
佐藤：

「テキスト連携の要件がほぼ固まったので、
“時間で微調整”ではなく“段落単位でジャンプ”を中核にすると整理したい。」

これまで：

「5秒戻る」「時間で戻る」案 → ユーザー操作としてストレスになりそう

ニーズは：

意味がわからなかったところをすぐ文字で確認したい

必要ならその段落から聞き直したい

よって、仕様をこう言い切る：

MVPのテキスト連携機能は：

今読んでいる段落にハイライト

段落をタップすると、その段落の頭から再生し直し

「“段落をタップすればそこが流れる”と覚えておけば、
5秒戻る・10秒戻るなど覚えなくてよい。
寝る前やながら作業でも直感的。」

2. 技術的な実現方法 🎯田中（エンジニア）
田中：

「段落単位でTTSする設計にしておけば、
『タップした段落から再生』はかなり素直に実装できる。」

2-1. 段落分割とインデックス
章テキストを読み込んだら：

改行・空行などで段落に分割
例：\n\n や、一定以上の連続改行で split

data class Paragraph(
    val index: Int,
    val text: String,
    val charStart: Int, // 元テキスト中の開始位置（後々の拡張用）
)
List<Paragraph> を持っておく

currentParagraphIndex: Int を状態として管理

2-2. 通常再生フロー
currentParagraphIndex = 0 からスタート

paragraphs[currentParagraphIndex].text を SpeechEngine.speak() に渡す

段落の読み上げが終わったら onComplete で currentParagraphIndex++ → 次の段落へ

2-3. タップ→再生フロー
UI側で：

段落ビューを onClick 可能にする

タップされた index を ViewModel 経由で PlaybackManager に渡す

疑似コード：

fun onParagraphClicked(index: Int) {
    playbackManager.playFromParagraph(
        novelId = currentNovelId,
        chapterId = currentChapterId,
        paragraphIndex = index
    )
}
PlaybackManager 側：

suspend fun playFromParagraph(novelId: Long, chapterId: Long, paragraphIndex: Int) {
    val chapter = repo.getChapter(chapterId)
    val text = loadChapterText(chapter)
    val paragraphs = paragraphSplitter.split(text)

    currentNovelId = novelId
    currentChapterId = chapterId
    currentParagraphIndex = paragraphIndex
    currentParagraphs = paragraphs

    playCurrentParagraph()
}

private fun playCurrentParagraph() {
    val p = currentParagraphs[currentParagraphIndex]
    speech.stop() // 再生中なら停止
    speech.speak(p.text)
    // UIに currentParagraphIndex を通知（ハイライト更新）
}
「“今どこを読んでいるか”は currentParagraphIndex のみで表現できるので、
UIはそれを見てハイライトするだけで済む。」

3. UI／UX：タップしやすさと誤タップ防止 🎨鈴木（UX）
鈴木：

「『読みたい段落をタップ → そこから再生』がコア操作になるので、
ここはあえて分かりやすく、かつ誤タップしにくく設計したい。」

3-1. 段落カード的な見た目
テキストエリアの中身を、
“段落ごとに軽くカード化” するイメージ：

段落ごとに上下にすこしパディング

行間も少し広め

背景色：

通常：透明〜ごく薄いグレー

現在再生中：淡い青／淡いハイライト色

タップ可能な領域を段落全体に広げる（行ごとではなく「塊」として）

3-2. タップ時のフィードバック
段落をタップしたら：

一瞬だけ「ポン」と軽いタップアニメーション

すぐにその段落の背景色が「再生中カラー」に変わる

上部の再生ボタンも「再生中状態」に変化

「これで、
“今、この段落が読み上げられ始めた”ことが視覚的に一致する。」

3-3. 誤タップ対策
長押しは不要（ユーザー負担が増える）ので、タップだけにする

誤タップしても：

もう一度元の段落をタップすれば戻れる
→ 「間違ってもすぐ戻せる」設計にしておく

4. TTSと段落タップの連携 🔍中村（音声）
中村：

「TTS側から見ると、“再生中に別段落から再スタート”は
『今の読み上げを止めて、新しいテキストを読む』だけなので、難しくはない。」

4-1. 注意したいポイント
stop → speak のタイミング

タップ → speech.stop() → speak(選択された段落)

stop と speak の間で妙なラグが出ないようにする（特にAndroid）

段落の長さのバラつき

短すぎる段落をそのまま1個1個読むと、音声がブツ切れになる
→ ルール例：

文字数があまりに短い段落（例：10文字未満）は、前後とまとめる

再生位置保存

PlaybackState としては

chapterId ＋ currentParagraphIndex だけ保存しておけば、
次回起動時に「前回の段落から」再生できる

「時間ベースの positionMillis ではなく、
“段落インデックス＋段落内の先頭” という発想に切り替える感じ。」

5. 読書家Fの感覚チェック 🌀
F：

「“5秒戻る”より
**“読んでほしい段落を押せばそこが流れる”**ほうが
断然わかりやすい。」

想定される使い方：

聞いていて意味が怪しいところがあったら：

ちょっと目を開けて画面を見る

ハイライトされている段落を読む

それでも曖昧なら、その段落をタップしてもう一回聞く

「特に寝る前って頭がボーッとしてるので、
“5秒戻すか10秒戻すか”考えるより、
**“この段落もう1回！”で済む方が楽。」

6. 仕様の確定：テキストまわりの最終イメージ
✅ テキスト表示＋操作仕様（MVP版）
章テキスト → 段落リストに分割

改行・空行ベースで分割

短すぎる段落はまとめるなど、簡易ルール

再生中の挙動

段落単位で順番にTTSにかける

今読んでいる段落に薄いハイライト背景

必要に応じて自動スクロール（現在段落が画面内に入るよう調整）

ユーザー操作

各段落をタップ → その段落を先頭から読み上げ

誤タップしたら、別の段落をタップし直せばOK

状態保存

「前回の続き」は

どの章の

どの段落まで読んだか
を記録しておく

5秒戻る・10秒戻るボタン

MVPからは外す

将来、「どうしても時間単位で戻したい」という声が多ければ検討

議論の質評価
ユーザーからの「5秒戻るはいらない」「段落タップ再生は必須」という要望に対して、
技術・UX・TTS・ユーザー視点で矛盾なく再設計できた

「段落ハイライト＋タップ再生」をMVPの正式仕様として固めるところまで到達

自己評価：96点 / 100点

次に進むステップメニュー
次に進むステップを選択：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「なろう／カクヨム向けの“段落分割ルール”をもっと具体化」

例）「再生画面1枚のレイアウトを完成形まで描く」

さらに意外な視点から議論する

さらに議論を続ける

実行可能な次のアクションを提案

「段落タップ再生・ハイライトを実装するためのタスク分解」

結論をまとめる

最初に戻る

番号か、「再生画面を固めたい」「段落分割ルールを詰めたい」など方向性だけでも次に進める。

あなた:
再生中は画面触ってもそのまま再生を続けて

違う段落から始めたい時は一度停止してから　段落タップして再生を押す。

スリープも　押してから再生した時だけ作動で
深層ディスカッションAI の発言：

思考時間: 5s
了解、そのルールかなりスッキリしていて、実装側としても筋が良いです。

✅ 再生中は画面を触っても「再生状態」は変わらない
✅ 段落ジャンプは「一度停止 → 段落タップ → 再生ボタン」の3ステップが必須
✅ スリープタイマーは「設定してから再生ボタンを押した時だけ」カウント開始

この3つを前提に、挙動を仕様レベルまで整理します。

👥 メンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・TTS/おやすみモード）🔍深掘り型

読書家F（ことせかい難民ペルソナ）🌀パラドックス型

1. 仕様としての整理（状態マシン的に）🧠佐藤
まず、ユーザーの希望を状態＋操作でハッキリさせる。

状態はざっくり3つ
停止中（Idle / Paused）

再生中（Playing）

停止＆スリープタイマー予約済み（Sleep-armed idle）
※実装上は「停止中＋sleepArmed = true」みたいなフラグ

操作と挙動
再生ボタン

停止中 → 再生開始

再生中 → 一時停止

段落タップ

再生中：
→ 「今どの段落を再生しているか」は変えない（ハイライトも変えない）
テキストをスクロールするだけOK

停止中：
→ 「次に再生する段落」をその段落にセット
（ハイライトも「これが次に再生される段落」に変わる）

スリープボタン

押した瞬間は 「設定値記録だけ」 にしておく

実際にカウントダウンが始まるのは、
→ その後に再生ボタンを押して再生が始まったタイミング

こうすると、「再生中にうっかり画面触っても音は途切れない」という安心感と
「どこから再開されるかは 止めて・選んで・再生 で自分でコントロール」という明確さが両立する。

2. 実装レベルの挙動 🎯田中（エンジニア）
田中：

「状態とイベントを決めておくと、バグりにくくなります。」

2-1. コア状態
enum class PlayerState {
    STOPPED,
    PLAYING,
    PAUSED
}

data class PlayerUiState(
    val state: PlayerState,
    val currentParagraphIndex: Int,   // 今実際に再生中 or 次に再生する段落
    val sleepMinutes: Int?,           // ユーザーが設定した時間（例：30）
    val sleepArmed: Boolean           // 「次の再生からスリープ有効」フラグ
)
2-2. ユーザー操作 → 挙動
再生ボタン
fun onPlayPauseClicked() {
    when (state.state) {
        STOPPED, PAUSED -> {
            // 再生開始
            startPlaybackFrom(state.currentParagraphIndex)
            if (state.sleepArmed && state.sleepMinutes != null) {
                startSleepTimer(state.sleepMinutes)
            }
            // sleepArmed は true のままでもいいし、
            // 一度使ったら false に戻す方針でもOK（これは要検討）
        }
        PLAYING -> {
            pausePlayback()
            // スリープタイマーはいったん停止か、そのままカウント継続かを決める必要あり
            // ユーザーの意図的には「一時停止したらタイマーも止まる」方が分かりやすいかも
        }
    }
}
段落タップ
fun onParagraphClicked(index: Int) {
    when (state.state) {
        PLAYING -> {
            // 再生中は「読む位置」は変更しない
            // 画面のスクロールだけUI側で処理して、ここでは何もしない
        }
        STOPPED, PAUSED -> {
            // 「次に再生する段落」を変更
            state = state.copy(currentParagraphIndex = index)
            // UI側では、この段落を「次の再生位置」としてハイライト
        }
    }
}
スリープボタン
fun onSleepTimerSet(minutes: Int?) {
    // minutes = null なら OFF
    state = state.copy(
        sleepMinutes = minutes,
        sleepArmed = minutes != null
    )
    // → 再生中なら「次に再生開始したときに有効になる」イメージ
    //   （今の再生には突然影響しない）
}
こうすれば、「再生中は画面いじっても音はそのまま」「開始地点を変えたいときは、一度止めてから選ぶ」が自然に実現できる。

3. 画面上の振る舞いイメージ 🎨鈴木（UX）
鈴木：

「ユーザーから見て“何をしたら何が起きるか”が一目で分かるようにしたい。」

3-1. 再生中のテキスト
下部のテキストエリアには、段落ごとのブロック

再生中の段落だけ背景色ハイライト

再生中に段落をタップしても：

ハイライトは変わらない（＝再生位置は変わらない）

テキストはスクロールできるので、「見て確認」だけはOK

→ 「触っても音が止まらない」「うっかり違う段落に飛ばない」のが安心。

3-2. 停止中のテキスト
一時停止 or 再生完了後の状態

段落をタップすると：

その段落に薄い“次に再生”ハイライト（色やスタイルを少し変えてもいい）

上部のプレイボタンは「▶ 次の段落から再生」と視覚的に一貫

3-3. スリープタイマーの視覚
スリープボタンで時間を選ぶと：

「30分後に停止します」などの表示（小さなテキストでもOK）

ただし、この時点ではまだカウントダウンは始まらない

再生ボタンを押した瞬間に：

画面のどこかに「スリープ：あと28分」みたいな残り表示（MVPでは簡単でもOK）

「スリープ押したのに止まらなかった」は絶対避けたいので、
“スリープは「次の再生に予約」する機能”とUIでも伝えたい。

4. 音声・おやすみモードとの整合性 🔍中村
中村：

「この仕様は、“寝る前に目を閉じて聞く”ユースケースとも相性が良い。」

4-1. 再生中：触っても止まらない
布団の中でスマホを握っていて、誤タップしても再生が止まらない
→ 寝落ち前のイライラが減る

4-2. 再生位置の変更フロー
「ちゃんと読み直したい」ときだけ、

一度目を開けて

再生ボタンを押して一時停止

段落をタップして

再生ボタンで再開

→ 意図的な操作が必要なので、「うっかり飛んでしまう」事故が減る。

4-3. スリープ挙動
ユーザーイメージ：

先に「30分スリープ」をセットしておく

そのあとで再生ボタンを押したら「30分カウントスタート」

途中で一時停止した場合：

タイマーも一回止めてしまうか

そのままカウントし続けるか
→ 中村的には「一時停止でタイマーも止まる」方が直感的、とコメント

「 ‘聞いてないのにスリープ時間だけ減っていく’ と、ちょっと損した気持ちになるので、停止中はタイマーも止める設計を推したい。」

5. 読書家Fの感覚チェック 🌀
F：

「これはかなりストレス少なそう。」

感じているメリット：

再生中に寝ぼけて画面さわっても、
→ 変なところに飛ばずに済む

読み直したい時も、

一時停止して

段落選んで

再生
という“確実な3ステップ”なので、誤操作しにくい

スリープも

「設定して、再生したときだけ動く」というルールが分かりやすい

「“押した瞬間からカウントが始まる”タイプのスリープは混乱しやすいから、
この仕様の方が覚えやすくて助かる。」

6. 仕様としてのまとめ（テキスト周り＋スリープの最終版）
✅ 再生と段落タップ
再生中：

段落タップ → 再生位置は変えない（スクロール＆閲覧のみ）

ハイライトは 今実際に読んでいる段落 だけが変わる

停止中：

段落タップ → 「次に再生する段落」を変更

ハイライトも「次の開始位置」としてその段落に移動

再生ボタン → その段落の先頭から再生開始

✅ スリープタイマー
スリープボタンで時間を選ぶ → 「次の再生に適用される」予約

再生ボタンを押した瞬間に、タイマーのカウント開始

一時停止したら、タイマーも一時停止（方向性として推奨）

この仕様なら、
**「再生中に触っても安全」「読み直したいときは意図的な操作」「スリープは予約してから聞き始める」**という、分かりやすい三本柱になる。

議論の質評価
ユーザーの具体的な要望（「再生中に触ってもそのまま」「段落ジャンプは停止→タップ→再生」「スリープは再生後だけ有効」）を
状態マシン・コード・UIレベルまで落とし込めた

寝る前利用や誤タップなど、実際の利用シーンとの整合性も確認できた

自己評価：96点 / 100点

次に進むステップメニュー
次に進むステップを選んでください：

もう一度根本から考え直す

現在の議論の改善点を探る

専門家を変えて議論する

視点を変えて深掘る

例）「再生画面全体のレイアウトを1枚にまとめる」

例）「なろう／カクヨム対応の取得〜段落分割ロジック」

さらに意外な視点から議論する

さらに議論を続ける

実行可能な次のアクションを提案

今まで決めた仕様を前提に、「まず何から実装に着手するか」具体タスク化

結論をまとめる

最初に戻る

番号でも、「再生画面UIをはっきりさせたい」「段落分割ルールを詰めたい」など一言でもOK。

あなた:
停止するとタイマー復活
(再生スタートすると30分で来れる)に戻る
深層ディスカッションAI の発言：

思考時間: 10s
結論から言うと、
いまの希望はこうですね：

🔁 「停止したら、スリープタイマーは復活（リセット）」
▶️ 次に再生ボタンを押した瞬間から、またフル（例：30分）カウント開始

この仕様にはっきり寄せ直す形で整理し直します。

👥 メンバー
司会：モデレーターM

佐藤（プロダクトマネージャー）🧠正統派

田中（モバイルエンジニア）🎯実務視点

鈴木（UXデザイナー）🎨創造型

中村（音声・おやすみモード）🔍深掘り型

読書家F（ヘビーユーザー）🌀パラドックス型

1. どういう挙動にしたいかの固定化 🧠佐藤
ユーザーの意図を日本語で言い直すと：

スリープ30分をセット

再生スタート → 30分後に止まる

途中で一時停止・停止したら：

タイマーはいったんクリアされる

でも「30分スリープを使う設定」は生きている（＝復活）

もう一度再生ボタンを押した瞬間：

また「そこから30分」でカウントし直し

つまり、

⏰スリープ時間は「1セッションあたりの再生時間の上限」
停止したら、そのセッションは終了 → 次の再生ではまたフル時間でスタート

というルール。

2. 実装側の挙動ルール 🎯田中（エンジニア）
田中：

「じゃあ、ロジックとしては
『設定値（30分）』と『実際の締切時刻』を分ける感じになります。」

2-1. 内部のイメージ
sleepMinutes：ユーザーが選んだ値（例：30）

sleepArmed：スリープ機能がONかどうか

sleepDeadline：実際に「この時刻になったら止める」という時刻（再生開始時に決まる）

2-2. 操作ごとの挙動
1. スリープボタンで時間設定

例：30分を選ぶ

内部状態：

sleepMinutes = 30

sleepArmed = true

sleepDeadline = null（まだ再生してないので締切は決めない）

2. 再生ボタンを押す（スタート）

if (sleepArmed && sleepMinutes != null) {
    sleepDeadline = now + sleepMinutes * 60_000
}
startPlayback()
ここで初めて「◯時◯分まで再生」の締切が決まる

3. 再生中、停止 or 一時停止を押したら

pauseOrStopPlayback()
sleepDeadline = null // タイマーはクリア（＝復活状態）
sleepMinutes と sleepArmed はそのまま残す
→ 次回、再生ボタンを押したらまた「そこから30分」

4. スリープをOFFにしたいとき

スリープ設定画面で「OFF」を選ぶ

内部状態：

sleepMinutes = null

sleepArmed = false

sleepDeadline = null

これで、「停止するとタイマー復活（＝次に再生した時はまたフル時間）」がキレイに実現できる。

3. UX的な見え方 🎨鈴木
鈴木：

「ユーザーの直感としては
『スリープ時間は“1回の視聴枠”の長さ』
という感じで見せてあげると理解しやすい。」

3-1. 画面メッセージのイメージ
スリープ30分セット時：

小さく「スリープ：30分」と表示

再生中：

「スリープ：あと27分」のようにカウントダウン表示（MVPなら省略してもいいが、あると親切）

3-2. 停止したとき
再生停止ボタンを押した瞬間：

カウント表示は消える or グレーアウト

表示は「スリープ：30分（次の再生から有効）」みたいなニュアンス

「停止するとタイマー復活」という感覚を
UIで表現するとすれば、
“カウント表示が消えるけど、右上に『30分スリープセット済』とか小さく残る”イメージ。

4. おやすみモードとの関係 🔍中村
中村：

「おやすみモードと組み合わせても、この仕様は相性がいい。」

🌙おやすみモードON：

デフォルトでスリープ30分を自動設定（変更可）

画面を暗く・シンプルに

再生ボタンを押す：

そこから30分カウントスタート

途中で一時停止／完全停止：

カウントはクリア（＝次の再生でまた30分）

もう一度再生：

再度30分枠スタート

「寝る前って、一回トイレ行ったり、水飲んだりで再生を止めることがちょこちょこあるので、
再開したときにまた“フルで30分枠”をくれるのは使いやすい。」

5. 読書家F目線での確認 🌀
Fの感覚：

「“スリープは押した瞬間から消費されていく”アプリって、
一回止めただけで残り時間が減りまくっててモヤモヤするんですよね。」

今回の仕様だと：

スリープセット → 再生 → 寝落ちまで30分

途中で一時停止して、しばらく用事して…

もう一回再生 → また30分枠始まる

「これなら、“スリープ時間をケチられてる感”もないし、
分かりやすいのでこの仕様が好き。」

6. テキスト・段落タップとの整合性
大事なのはここ：

すでに決めたルール：

再生中は、画面触っても再生は続ける

別の段落から聞きたいときは
「停止 → 段落タップ → 再生」

スリープの挙動をそれに合わせると：

「停止」した瞬間に：

再生停止

sleepDeadline クリア（タイマー復活）

そのまま段落タップ（開始位置変更）

「再生」ボタン：

その段落の頭から読み上げ開始

sleepDeadline = now + sleepMinutes * 60_000 で再セット

→
「停止→段落変更→再生」＝「新しい30分セッション開始」
という、筋の通った動きになる。

議論の質評価
スリープタイマーの挙動を、
ユーザーの希望（停止で復活・再生ごとにフル時間）に合わせて
状態・コード・UIレベルで矛盾なく整理できた

テキスト・段落タップ・おやすみモードとの整合性も確認済み

自己評価：95点 / 100点
